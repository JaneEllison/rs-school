!function(Q){var B={};function n(F){if(B[F])return B[F].exports;var e=B[F]={i:F,l:!1,exports:{}};return Q[F].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=Q,n.c=B,n.d=function(Q,B,F){n.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:F})},n.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},n.t=function(Q,B){if(1&B&&(Q=n(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var F=Object.create(null);if(n.r(F),Object.defineProperty(F,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var e in Q)n.d(F,e,function(B){return Q[B]}.bind(null,e));return F},n.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return n.d(B,"a",B),B},n.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},n.p="",n(n.s=2)}([function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(1);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/YTM0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFxQiIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, "");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    "GeneratorFunction"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, "GeneratorFunction");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke("throw", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        // Note: ["return"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator["return"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, "Generator");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you\'ve misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you\'re not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function("r", "regeneratorRuntime = r")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSztBQUNMLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLFNBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./styles/scss/main.scss\n// extracted by mini-css-extract-plugin\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(0);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./js/components/map.js\n\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar leaflet = window.L;\nvar covidMap = leaflet.map('mapid').setView([0, 0], 2);\nvar isCovidInfo = true;\nvar covidControl = document.querySelector('.map__control');\nvar attribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\nvar tileLayerUrl = 'https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png';\nvar tiles = leaflet.tileLayer(tileLayerUrl, {\n  attribution: attribution\n});\ntiles.addTo(covidMap);\n\nvar createMarkerUi = function createMarkerUi(width, height) {\n  var covidMarker = leaflet.icon({\n    iconUrl: isCovidInfo ? '../assets/images/covid-marker1.png' : '../assets/images/covid-marker2.png',\n    iconSize: [width, height],\n    iconAnchor: [25, 16],\n    className: 'marker_img'\n  });\n  return covidMarker;\n};\n\nvar geoCovidMarker = function geoCovidMarker(covidApiData) {\n  var geoFormat = {\n    type: 'FeatureCollection',\n    features: covidApiData.map(function (element) {\n      var countryInfo = element.countryInfo;\n      var lat = countryInfo.lat,\n          _long = countryInfo[\"long\"];\n\n      if (element.cases > 400000 && element.cases < 900000) {\n        var covidIcon = createMarkerUi(60, 50);\n        leaflet.marker([lat, _long], {\n          icon: covidIcon\n        }).addTo(covidMap);\n      }\n\n      if (element.cases < 400000) {\n        var _covidIcon = createMarkerUi(20, 15);\n\n        leaflet.marker([lat, _long], {\n          icon: _covidIcon\n        }).addTo(covidMap);\n      }\n\n      if (element.cases > 900000) {\n        var _covidIcon2 = createMarkerUi(100, 90);\n\n        leaflet.marker([lat, _long], {\n          icon: _covidIcon2\n        }).addTo(covidMap);\n      }\n\n      var covidGeoInf = {\n        type: 'Feature',\n        geometry: {\n          type: 'Point',\n          coordinates: [_long, lat]\n        },\n        properties: _objectSpread({}, element)\n      };\n      return covidGeoInf;\n    })\n  };\n  return geoFormat;\n};\n\nvar createPopupCovid = function createPopupCovid(geoFeature) {\n  var geoJsonPoint = new leaflet.GeoJSON(geoFeature, {\n    pointToLayer: function pointToLayer(covidGeoInf, coordinates) {\n      var properties = covidGeoInf.properties;\n      var population = properties.population,\n          country = properties.country,\n          cases = properties.cases,\n          deaths = properties.deaths,\n          recovered = properties.recovered,\n          todayCases = properties.todayCases,\n          todayDeaths = properties.todayDeaths,\n          todayRecovered = properties.todayRecovered,\n          casesPerOneMillion = properties.casesPerOneMillion,\n          recoveredPerOneMillion = properties.recoveredPerOneMillion,\n          deathsPerOneMillion = properties.deathsPerOneMillion;\n      var marker = leaflet.marker(coordinates, {\n        icon: leaflet.divIcon({\n          className: 'markerPopup',\n          html: \"\".concat(isCovidInfo ? \"<div class=\\\"covid__container\\\">\\n              <div class=\\\"covid__content\\\">\\n                <h2 class=\\\"covid__country\\\">\".concat(country, \":</h2>\\n                <div>\\n                  <span><h3 class=\\\"covid__info\\\">Population: \").concat(population, \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">TotalConfirmed: \").concat(cases, \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">TotalDeaths: \").concat(deaths, \"</h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">TotalRecovered: \").concat(recovered, \"</h3></span>\\n                </div>\\n              </div>\\n            </div>\") : \"<div class=\\\"covid__container\\\">\\n              <div class=\\\"covid__content\\\">\\n                <h2 class=\\\"covid__country\\\">\".concat(country, \":</h2>\\n                <div>\\n                  <span><h3 class=\\\"covid__info\\\">TodayConfirmed: \").concat(todayCases, \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">TodayDeaths: \").concat(todayDeaths, \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">TodayRecovered: \").concat(todayRecovered, \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">Per100 Corfirmed: \").concat(Math.round(casesPerOneMillion / 10), \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">Per100 Recovered: \").concat(Math.round(recoveredPerOneMillion / 10), \" </h3></span>\\n                  <span><h3 class=\\\"covid__info\\\">Per100 Deaths: \").concat(Math.round(deathsPerOneMillion / 10), \" </h3></span>\\n                </div>\\n              </div>\\n            </div>\"))\n        }),\n        riseOnHover: true\n      });\n      return marker;\n    }\n  });\n  geoJsonPoint.addTo(covidMap);\n};\n\nvar covidData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var response, covidApiData, geoFeature;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch('https://corona.lmao.ninja/v2/countries');\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.json();\n\n          case 5:\n            covidApiData = _context.sent;\n            geoFeature = geoCovidMarker(covidApiData);\n            createPopupCovid(geoFeature);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function covidData() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar covidControlAction = function covidControlAction(event) {\n  if (event.target.getAttribute('class').slice(-7) === 'control') return;\n  var markerPopup = document.querySelectorAll('.markerPopup');\n  var markerImg = document.querySelectorAll('.marker_img');\n  var activeBtn = document.querySelector('.actual');\n  markerImg.forEach(function (el) {\n    el.remove();\n  });\n  markerPopup.forEach(function (el) {\n    el.remove();\n  });\n\n  if (event.target.getAttribute('class').slice(-5) === 'total') {\n    isCovidInfo = true;\n    covidData();\n  }\n\n  if (event.target.getAttribute('class').slice(-5) === 'today') {\n    isCovidInfo = false;\n    covidData();\n  }\n\n  if (activeBtn !== null) {\n    activeBtn.classList.remove('actual');\n  }\n\n  event.target.classList.add('actual');\n};\n\ncovidMap.addControl(new leaflet.Control.Fullscreen());\ncovidData();\ncovidControl.addEventListener('click', function (event) {\n  return covidControlAction(event);\n});\n// CONCATENATED MODULE: ./js/components/table.js\n\n\nvar countries = document.querySelector('.countries');\nvar table = document.querySelector('.table');\nvar fullscreenTableBtn = document.querySelector('.fullscreen__table');\nvar countryFlag = document.querySelector('.country__flag');\nvar countryName = document.querySelector('.country__name');\nvar tableConfirmed = document.querySelector('.table__confirmed');\nvar tableDeath = document.querySelector('.table__death');\nvar tableRecovered = document.querySelector('.table__recovered');\nvar tableSwitherDays = document.querySelector('.table__swither_days');\nvar arrowLeftDays = document.querySelector('.arrow__left_days');\nvar tableGlobal = document.querySelector('.table__global');\nvar tableDaily = document.querySelector('.table__daily');\nvar arrowRightDays = document.querySelector('.arrow__right_days');\nvar tableSwitherCount = document.querySelector('.table__swither_count');\nvar arrowLeftCount = document.querySelector('.arrow__left_count');\nvar tableAll = document.querySelector('.table__all');\nvar tablePer100 = document.querySelector('.table__per100');\nvar arrowRightCount = document.querySelector('.arrow__right_count');\nvar totalBtn = document.querySelector('.total__btn');\nvar countryCasesData;\nvar allCasesData;\nvar isGlobalCasesMode = true;\nvar isAllCasesMode = true;\nvar currentCountry;\nvar currentCountryData;\nvar isCountryMode;\nvar worldPopulationPer100 = 78270;\n\nvar getData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch('https://corona.lmao.ninja/v2/countries').then(function (res) {\n              return res.json();\n            });\n\n          case 2:\n            countryCasesData = _context.sent;\n            _context.next = 5;\n            return fetch('https://api.covid19api.com/summary').then(function (res) {\n              return res.json();\n            });\n\n          case 5:\n            allCasesData = _context.sent;\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getData() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar getInfoTable = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    var confirmed, death, recovered;\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getData();\n\n          case 2:\n            if (!isCountryMode) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 4:\n            if (isGlobalCasesMode && isAllCasesMode) {\n              confirmed = allCasesData.Global.TotalConfirmed;\n              death = allCasesData.Global.TotalDeaths;\n              recovered = allCasesData.Global.TotalRecovered;\n            } else if (!isGlobalCasesMode && isAllCasesMode) {\n              confirmed = allCasesData.Global.NewConfirmed;\n              death = allCasesData.Global.NewDeaths;\n              recovered = allCasesData.Global.NewRecovered;\n            } else if (isGlobalCasesMode && !isAllCasesMode) {\n              confirmed = Math.round(allCasesData.Global.TotalConfirmed / worldPopulationPer100);\n              death = Math.round(allCasesData.Global.TotalDeaths / worldPopulationPer100);\n              recovered = Math.round(allCasesData.Global.TotalRecovered / worldPopulationPer100);\n            } else if (!isGlobalCasesMode && !isAllCasesMode) {\n              confirmed = Math.round(allCasesData.Global.NewConfirmed / worldPopulationPer100);\n              death = Math.round(allCasesData.Global.NewDeaths / worldPopulationPer100);\n              recovered = Math.round(allCasesData.Global.NewRecovered / worldPopulationPer100);\n            }\n\n            createCountryTable('World', 'assets/images/world-icon.png', confirmed, death, recovered);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getInfoTable() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getCurrentCountry = function getCurrentCountry() {\n  currentCountryData = countryCasesData.find(function (country) {\n    return currentCountry === country.country;\n  });\n};\n\nvar getCountryInfo = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\n    var confirmed, death, recovered;\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return getData();\n\n          case 2:\n            if (isCountryMode) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 4:\n            if (isGlobalCasesMode && isAllCasesMode) {\n              confirmed = currentCountryData.cases;\n              death = currentCountryData.deaths;\n              recovered = currentCountryData.recovered;\n            } else if (!isGlobalCasesMode && isAllCasesMode) {\n              confirmed = currentCountryData.todayCases;\n              death = currentCountryData.todayDeaths;\n              recovered = currentCountryData.todayRecovered;\n            } else if (isGlobalCasesMode && !isAllCasesMode) {\n              confirmed = Math.round(currentCountryData.casesPerOneMillion / 10);\n              death = Math.round(currentCountryData.deathsPerOneMillion / 10);\n              recovered = Math.round(currentCountryData.recoveredPerOneMillion / 10);\n            } else if (!isGlobalCasesMode && !isAllCasesMode) {\n              confirmed = Math.round(currentCountryData.todayCases / currentCountryData.population * 100000);\n              death = Math.round(currentCountryData.todayDeaths / currentCountryData.population * 100000);\n              recovered = Math.round(currentCountryData.todayRecovered / currentCountryData.population * 100000);\n            }\n\n            createCountryTable(currentCountryData.country, currentCountryData.countryInfo.flag, confirmed, death, recovered);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function getCountryInfo() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar createCountryTable = function createCountryTable(country, flag, confirmed, death, recovered) {\n  countryFlag.innerHTML = \"<img src=\\\"../\".concat(flag, \"\\\" class=\\\"flag__img\\\">\");\n  countryName.innerText = country;\n  tableConfirmed.innerText = confirmed;\n  tableDeath.innerText = death;\n  tableRecovered.innerText = recovered;\n}; //clean numbers\n\n\nvar cleanTable = function cleanTable() {\n  tableConfirmed.innerHTML = '';\n  tableDeath.innerHTML = '';\n  tableRecovered.innerHTML = '';\n};\n\nvar changeTableNameMode = function changeTableNameMode(firstMode, secondMode) {\n  firstMode.classList.toggle('hide');\n  secondMode.classList.toggle('hide');\n};\n\nvar changeTableArrows = function changeTableArrows(firstArrow, secondArrow) {\n  firstArrow.classList.toggle('unactive');\n  secondArrow.classList.toggle('unactive');\n}; //days swither right\n\n\narrowRightDays.addEventListener('click', function () {\n  if (isGlobalCasesMode) {\n    changeTableNameMode(tableGlobal, tableDaily);\n    changeTableArrows(arrowLeftDays, arrowRightDays);\n    isGlobalCasesMode = false;\n  }\n\n  cleanTable();\n  getInfoTable();\n  getCountryInfo();\n}); //days swither left\n\narrowLeftDays.addEventListener('click', function () {\n  if (!isGlobalCasesMode) {\n    changeTableNameMode(tableGlobal, tableDaily);\n    changeTableArrows(arrowLeftDays, arrowRightDays);\n    isGlobalCasesMode = true;\n  }\n\n  cleanTable();\n  getInfoTable();\n  getCountryInfo();\n}); //count swither right\n\narrowRightCount.addEventListener('click', function () {\n  if (isAllCasesMode) {\n    changeTableNameMode(tableAll, tablePer100);\n    changeTableArrows(arrowLeftCount, arrowRightCount);\n    isAllCasesMode = false;\n  }\n\n  cleanTable();\n  getInfoTable();\n  getCountryInfo();\n}); //count swither left\n\narrowLeftCount.addEventListener('click', function () {\n  if (!isAllCasesMode) {\n    changeTableNameMode(tableAll, tablePer100);\n    changeTableArrows(arrowLeftCount, arrowRightCount);\n    isAllCasesMode = true;\n  }\n\n  cleanTable();\n  getInfoTable();\n  getCountryInfo();\n}); //choose country for table\n\ncountries.addEventListener('click', function (event) {\n  cleanTable();\n  var target = event.target;\n\n  if (target.className !== 'country__name') {\n    currentCountry = currentCountry;\n  } else {\n    currentCountry = target.innerText;\n  }\n\n  isCountryMode = true;\n  getCurrentCountry();\n  getCountryInfo();\n}); //return to total cases\n\ntotalBtn.addEventListener('click', function () {\n  isCountryMode = false;\n  cleanTable();\n  getInfoTable();\n}); //add full Screen\n\nfullscreenTableBtn.addEventListener('click', function () {\n  if (!document.fullscreen) {\n    table.requestFullscreen();\n    fullscreenTableBtn.style.top = '0.5rem';\n    fullscreenTableBtn.style.right = '0.5rem';\n  } else {\n    document.exitFullscreen();\n    fullscreenTableBtn.style.top = '-0.4rem';\n    fullscreenTableBtn.style.right = '-0.4rem';\n  }\n\n  ;\n});\ndocument.addEventListener('DOMContentLoaded', function () {\n  getInfoTable();\n});\n// CONCATENATED MODULE: ./js/components/list.js\n\n\nvar fullscreenBtn = document.querySelector('.fullscreen__list');\nvar list = document.querySelector('.list');\nvar list_countries = document.querySelector('.countries');\nvar input = document.getElementById('search');\nvar daysMode = document.querySelector('.days__mode');\nvar countsMode = document.querySelector('.counts__mode');\nvar globalCases = document.querySelector('.global__cases');\nvar dailyCases = document.querySelector('.daily__cases');\nvar allCases = document.querySelector('.all__cases');\nvar thousandsCases = document.querySelector('.thousands__cases');\nvar arrowRight = document.querySelector('.arrow__right_list');\nvar arrowLeft = document.querySelector('.arrow__left_list');\nvar list_confirmed = document.querySelector('.confirmed');\nvar deaths = document.querySelector('.deaths');\nvar list_recovered = document.querySelector('.recovered');\nvar keyboardBtn = document.querySelector('.keyboard__btn');\nvar keyboardContainer = document.querySelector('.keyboardContainer');\nvar virtualKeyboard = document.querySelector('.virtual__keyboard');\nvar DATA;\nvar list_isGlobalCasesMode = true;\nvar list_isAllCasesMode = true;\nvar countClickArrow = 0;\nvar isConfirmedMode = true;\nvar isDeathCasesMode = false;\nvar isRecoveredMode = false;\nvar searchTerm = '';\nvar Keyboard = window.SimpleKeyboard[\"default\"];\nvar myKeyboard = new Keyboard({\n  onChange: function onChange(input) {\n    return _onChange(input);\n  },\n  useMouseEvents: true\n});\n\nvar fetchData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch('https://corona.lmao.ninja/v2/countries').then(function (res) {\n              return res.json();\n            });\n\n          case 2:\n            DATA = _context.sent;\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchData() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar seachCountries = function seachCountries() {\n  DATA = DATA.filter(function (country) {\n    return country.country.toLowerCase().includes(searchTerm.toLowerCase());\n  });\n};\n\nvar getInfo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fetchData();\n\n          case 2:\n            seachCountries();\n            DATA.forEach(function (country) {\n              if (country.country === 'MS Zaandam') {\n                country.population = 76804;\n              }\n\n              if (country.country === 'Diamond Princess') {\n                country.population = 28670;\n              }\n            });\n\n            if (list_isGlobalCasesMode && list_isAllCasesMode && isConfirmedMode) {\n              DATA.sort(function (a, b) {\n                return a.cases < b.cases ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.cases);\n              });\n            } else if (!list_isGlobalCasesMode && list_isAllCasesMode && isConfirmedMode) {\n              DATA.sort(function (a, b) {\n                return a.todayCases < b.todayCases ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.todayCases);\n              });\n            } else if (list_isGlobalCasesMode && !list_isAllCasesMode && isConfirmedMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.casesPerOneMillion / 10) < Math.round(b.casesPerOneMillion / 10) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var totalConfirmedPer100 = Math.round(country.casesPerOneMillion / 10);\n                createCards(country, totalConfirmedPer100);\n              });\n            } else if (!list_isGlobalCasesMode && !list_isAllCasesMode && isConfirmedMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.todayCases / a.population * 100000) < Math.round(b.todayCases / b.population * 100000) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var newConfirmedPer100 = Math.round(country.todayCases / country.population * 100000);\n                createCards(country, newConfirmedPer100);\n              });\n            } else if (list_isGlobalCasesMode && list_isAllCasesMode && isDeathCasesMode) {\n              DATA.sort(function (a, b) {\n                return a.deaths < b.deaths ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.deaths);\n              });\n            } else if (!list_isGlobalCasesMode && list_isAllCasesMode && isDeathCasesMode) {\n              DATA.sort(function (a, b) {\n                return a.todayDeaths < b.todayDeaths ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.todayDeaths);\n              });\n            } else if (list_isGlobalCasesMode && !list_isAllCasesMode && isDeathCasesMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.deaths / a.population * 100000) < Math.round(b.deaths / b.population * 100000) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var totalDeathsPer100 = Math.round(country.deaths / country.population * 100000);\n                createCards(country, totalDeathsPer100);\n              });\n            } else if (!list_isGlobalCasesMode && !list_isAllCasesMode && isDeathCasesMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.todayDeaths / a.population * 100000) < Math.round(b.todayDeaths / b.population * 100000) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var newDeathsPer100 = Math.round(country.todayDeaths / country.population * 100000);\n                createCards(country, newDeathsPer100);\n              });\n            } else if (list_isGlobalCasesMode && list_isAllCasesMode && isRecoveredMode) {\n              DATA.sort(function (a, b) {\n                return a.recovered < b.recovered ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.recovered);\n              });\n            } else if (!list_isGlobalCasesMode && list_isAllCasesMode && isRecoveredMode) {\n              DATA.sort(function (a, b) {\n                return a.todayRecovered < b.todayRecovered ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                return createCards(country, country.todayRecovered);\n              });\n            } else if (list_isGlobalCasesMode && !list_isAllCasesMode && isRecoveredMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.recovered / a.population * 100000) < Math.round(b.recovered / b.population * 100000) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var totalRecoveredPer100 = Math.round(country.recovered / country.population * 100000);\n                createCards(country, totalRecoveredPer100);\n              });\n            } else if (!list_isGlobalCasesMode && !list_isAllCasesMode && isRecoveredMode) {\n              DATA.sort(function (a, b) {\n                return Math.round(a.todayRecovered / a.population * 100000) < Math.round(b.todayRecovered / b.population * 100000) ? 1 : -1;\n              });\n              DATA.forEach(function (country) {\n                var newRecoveredPer100 = Math.round(country.todayRecovered / country.population * 100000);\n                createCards(country, newRecoveredPer100);\n              });\n            }\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getInfo() {\n    return _ref2.apply(this, arguments);\n  };\n}(); //create elemets\n\n\nvar createCards = function createCards(country, numbers) {\n  var countryContainer = document.createElement('div');\n  var countryInfo = document.createElement('div');\n  var countryFlag = document.createElement('div');\n  var countryName = document.createElement('div');\n  var countryCases = document.createElement('div');\n  countryContainer.className = 'country__container';\n  countryInfo.className = 'country__info';\n  countryFlag.className = 'country__flag';\n  countryName.className = 'country__name';\n  countryCases.className = 'country__cases';\n  countryName.innerText = country.country;\n  countryCases.innerText = numbers;\n  countryFlag.innerHTML = \"<img src=\\\"\".concat(country.countryInfo.flag, \"\\\" class=\\\"flag__img\\\">\");\n  list_countries.append(countryContainer);\n  countryContainer.append(countryInfo, countryCases);\n  countryInfo.append(countryFlag, countryName);\n};\n\nvar _onChange = function _onChange(input) {\n  document.querySelector(\".input\").value = input;\n  searchTerm = input;\n  list_countries.innerHTML = '';\n  getInfo();\n}; //change Switchers\n\n\nvar changeSwitcherModeBtn = function changeSwitcherModeBtn(firstMode, secondMode) {\n  firstMode.classList.toggle('hide');\n  secondMode.classList.toggle('hide');\n};\n\nvar changeSwitchersDaysMode = function changeSwitchersDaysMode() {\n  if (list_isGlobalCasesMode) {\n    list_isGlobalCasesMode = false;\n  } else {\n    list_isGlobalCasesMode = true;\n  }\n\n  changeSwitcherModeBtn(globalCases, dailyCases);\n};\n\nvar changeSwitchersCasesMode = function changeSwitchersCasesMode() {\n  if (list_isAllCasesMode) {\n    list_isAllCasesMode = false;\n  } else {\n    list_isAllCasesMode = true;\n  }\n\n  changeSwitcherModeBtn(allCases, thousandsCases);\n}; // add full Screen\n\n\nfullscreenBtn.addEventListener('click', function () {\n  if (!document.fullscreen) {\n    list.requestFullscreen();\n    virtualKeyboard.classList.add('fullscreen_keyb');\n    fullscreenBtn.style.top = '0.5rem';\n    fullscreenBtn.style.right = '0.5rem';\n  } else {\n    document.exitFullscreen();\n    virtualKeyboard.classList.remove('fullscreen_keyb');\n    fullscreenBtn.style.top = '-0.4rem';\n    fullscreenBtn.style.right = '-0.4rem';\n  }\n\n  ;\n});\ndaysMode.addEventListener('click', function () {\n  list_countries.innerHTML = '';\n  changeSwitchersDaysMode();\n  getInfo();\n});\ncountsMode.addEventListener('click', function () {\n  list_countries.innerHTML = '';\n  changeSwitchersCasesMode();\n  getInfo();\n}); //change indicators\n\narrowRight.addEventListener('click', function () {\n  if (countClickArrow === 0) {\n    list_confirmed.classList.add('hide');\n    deaths.classList.remove('hide');\n    arrowLeft.classList.remove('unactive');\n    countClickArrow = 1;\n    isConfirmedMode = false;\n    isDeathCasesMode = true;\n  } else if (countClickArrow === 1) {\n    deaths.classList.add('hide');\n    list_recovered.classList.remove('hide');\n    arrowRight.classList.add('unactive');\n    countClickArrow = 2;\n    isDeathCasesMode = false;\n    isRecoveredMode = true;\n  }\n\n  list_countries.innerHTML = '';\n  getInfo();\n});\narrowLeft.addEventListener('click', function () {\n  if (countClickArrow === 1) {\n    list_confirmed.classList.remove('hide');\n    deaths.classList.add('hide');\n    arrowLeft.classList.add('unactive');\n    countClickArrow = 0;\n    isDeathCasesMode = false;\n    isConfirmedMode = true;\n  } else if (countClickArrow === 2) {\n    deaths.classList.remove('hide');\n    list_recovered.classList.add('hide');\n    arrowRight.classList.remove('unactive');\n    countClickArrow = 1;\n    isDeathCasesMode = true;\n    isRecoveredMode = false;\n  }\n\n  list_countries.innerHTML = '';\n  getInfo();\n});\ninput.addEventListener('input', function (event) {\n  searchTerm = event.target.value;\n  list_countries.innerHTML = '';\n  getInfo();\n});\ndocument.querySelector(\".input\").addEventListener(\"input\", function (event) {\n  keyboard.setInput(event.target.value);\n});\nkeyboardBtn.addEventListener('click', function () {\n  keyboardContainer.classList.toggle('hide');\n});\ndocument.addEventListener('DOMContentLoaded', function () {\n  getInfo();\n});\n// CONCATENATED MODULE: ./js/components/chart.js\n\n\n\n/* eslint-disable no-undef */\nvar chartGlobal = document.getElementById('chart_global_id');\nvar globalCasesButton = document.querySelector('.chart__control_global');\nvar worldCases = document.querySelector('.chart__global');\nvar chartDaily = document.getElementById('chart_daily_id');\nvar dailyCasesButton = document.querySelector('.chart__control_daily');\nvar chartHundred = document.getElementById('chart_hundred_id');\nvar hundredCasesButton = document.querySelector('.chart__control_hundred');\nvar chartBtnContainer = document.querySelector('.chart__control');\nvar fullscreenChartBtn = document.querySelector('.fullscreen__chart');\nvar chart = document.querySelector('.chart');\nvar globalConfirmed = [];\nvar globalDeaths = [];\nvar globalRecovered = [];\nvar dateStage = [];\nvar rightDate = [];\nvar newConfirmed = [];\nvar lastDate = '';\nvar newRecovered = [];\nvar newDeaths = [];\nvar globalChartCreated;\nvar dailyChartCreated;\nvar hundredChartCreated;\nvar isShowChart = true;\nvar isHundredChart = true;\nvar chart_worldPopulationPer100 = 78270;\nvar globalHundredConfirmed = [];\nvar globalHundredDeaths = [];\nvar globalHundredRecovered = [];\nvar todayHundredConfirmed = [];\nvar todayHundredDeaths = [];\nvar todayHundredRecovered = [];\nvar monthsNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\nvar formattedDate = function formattedDate(parseDate) {\n  var date = new Date(parseDate);\n  return \"\".concat(date.getDate(), \" \").concat(monthsNames[date.getMonth()]);\n};\n\nvar sortData = function sortData() {\n  globalConfirmed.sort(function (a, b) {\n    return a - b;\n  });\n  globalDeaths.sort(function (a, b) {\n    return a - b;\n  });\n  globalRecovered.sort(function (a, b) {\n    return a - b;\n  });\n  globalHundredConfirmed.sort(function (a, b) {\n    return a - b;\n  });\n  globalHundredDeaths.sort(function (a, b) {\n    return a - b;\n  });\n  globalHundredRecovered.sort(function (a, b) {\n    return a - b;\n  });\n  todayHundredConfirmed.sort(function (a, b) {\n    return a - b;\n  });\n  todayHundredDeaths.sort(function (a, b) {\n    return a - b;\n  });\n  todayHundredRecovered.sort(function (a, b) {\n    return a - b;\n  });\n  dateStage.sort();\n  dateStage.forEach(function (el) {\n    rightDate.push(formattedDate(el));\n  });\n};\n\nvar globalChartAction = function globalChartAction() {\n  if (!isShowChart || !isHundredChart) {\n    chartDaily.classList.remove('active');\n    worldCases.classList.add('active');\n    chartHundred.classList.remove('active');\n    isShowChart = true;\n    isHundredChart = true;\n  }\n};\n\nvar dailyChartAction = function dailyChartAction() {\n  if (isShowChart || !isHundredChart) {\n    worldCases.classList.remove('active');\n    chartDaily.classList.add('active');\n    chartHundred.classList.remove('active');\n    isShowChart = false;\n    isHundredChart = true;\n  }\n};\n\nvar createDailyChart = function createDailyChart() {\n  dailyChartCreated = new Chart(chartDaily, {\n    type: 'doughnut',\n    data: {\n      datasets: [{\n        label: 'Today`s Chart',\n        backgroundColor: ['#3e95cd', '#8e5ea2', '#3cba9f'],\n        data: [newConfirmed, newRecovered, newDeaths]\n      }],\n      labels: ['New Confirmed', 'New Recovered', 'New Deaths']\n    },\n    options: {\n      title: {\n        display: true,\n        text: \"Today`s Cases: \".concat(lastDate)\n      },\n      responsive: true,\n      maintainAspectRatio: false\n    }\n  });\n  return dailyChartCreated;\n};\n\nvar hundredChartAction = function hundredChartAction() {\n  if (isHundredChart) {\n    worldCases.classList.remove('active');\n    chartDaily.classList.remove('active');\n    chartHundred.classList.add('active');\n    isHundredChart = false;\n  }\n};\n\nvar createHundredChart = function createHundredChart() {\n  hundredChartCreated = new Chart(chartHundred, {\n    type: 'line',\n    data: {\n      datasets: [{\n        label: 'Global Per 100 Confirmed',\n        data: globalHundredConfirmed,\n        fill: false,\n        borderColor: '#3e95cd',\n        backgroundColor: '#3e95cd',\n        borderWidth: 1\n      }, {\n        label: 'Global Per 100 Recovered',\n        data: globalHundredRecovered,\n        fill: false,\n        borderColor: '#8e5ea2',\n        backgroundColor: '#8e5ea2',\n        borderWidth: 1\n      }, {\n        label: 'Global Per 100 Deaths',\n        data: globalHundredDeaths,\n        fill: false,\n        borderColor: 'red',\n        backgroundColor: 'red',\n        borderWidth: 1\n      }, {\n        label: 'Today Per 100 Confirmed',\n        data: todayHundredConfirmed,\n        fill: false,\n        borderColor: 'black',\n        backgroundColor: 'black',\n        borderWidth: 1\n      }, {\n        label: 'Today Per 100 Recovered',\n        data: todayHundredRecovered,\n        fill: false,\n        borderColor: 'blue',\n        backgroundColor: 'blue',\n        borderWidth: 1\n      }, {\n        label: 'Today Per 100 Deaths',\n        data: todayHundredDeaths,\n        fill: false,\n        borderColor: '#3cba9f',\n        backgroundColor: '#3cba9f',\n        borderWidth: 1\n      }],\n      labels: rightDate\n    },\n    options: {\n      legend: {\n        display: true,\n        position: 'top',\n        labels: {\n          boxWidth: 20,\n          fontSize: 11,\n          fontColor: 'darkslategray'\n        }\n      },\n      responsive: true,\n      maintainAspectRatio: false\n    }\n  });\n  return hundredChartCreated;\n};\n\nvar chart_covidData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var response, covidApiData, data;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch('https://corona-api.com/timeline');\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.json();\n\n          case 5:\n            covidApiData = _context.sent;\n            data = covidApiData.data;\n            data.forEach(function (el) {\n              dateStage.push(el.date);\n              globalConfirmed.push(el.confirmed);\n              globalDeaths.push(el.deaths);\n              globalRecovered.push(el.recovered);\n              globalHundredConfirmed.push(Math.round(el.confirmed / chart_worldPopulationPer100));\n              globalHundredDeaths.push(Math.round(el.deaths / chart_worldPopulationPer100));\n              globalHundredRecovered.push(Math.round(el.recovered / chart_worldPopulationPer100));\n              todayHundredConfirmed.push(Math.round(el.new_confirmed / chart_worldPopulationPer100));\n              todayHundredDeaths.push(Math.round(el.new_deaths / chart_worldPopulationPer100));\n              todayHundredRecovered.push(Math.round(el.new_recovered / chart_worldPopulationPer100));\n            });\n            newConfirmed.push(data[0].new_confirmed);\n            newRecovered.push(data[0].new_recovered);\n            newDeaths.push(data[0].new_deaths);\n            lastDate += data[0].date;\n            sortData();\n            createDailyChart();\n            createHundredChart();\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function covidData() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar chartButtonActive = function chartButtonActive(event) {\n  var targetBtn = event.target;\n  var activeBtn = document.querySelector('.open');\n\n  if (targetBtn.getAttribute('class') === 'chart__control') {\n    return;\n  }\n\n  if (activeBtn !== null) {\n    activeBtn.classList.remove('open');\n  }\n\n  targetBtn.classList.add('open');\n};\n\nvar createGlobalChart = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            worldCases.classList.add('active');\n            _context2.next = 3;\n            return chart_covidData();\n\n          case 3:\n            globalChartCreated = new Chart(chartGlobal, {\n              type: 'line',\n              data: {\n                datasets: [{\n                  label: 'Global Confirmed',\n                  data: globalConfirmed,\n                  fill: false,\n                  borderColor: '#3e95cd',\n                  backgroundColor: '#3e95cd',\n                  borderWidth: 1\n                }, {\n                  label: 'Global Recovered',\n                  data: globalRecovered,\n                  fill: false,\n                  borderColor: '#8e5ea2',\n                  backgroundColor: '#8e5ea2',\n                  borderWidth: 1\n                }, {\n                  label: 'Global Deaths',\n                  data: globalDeaths,\n                  fill: false,\n                  borderColor: '#3cba9f',\n                  backgroundColor: '#3cba9f',\n                  borderWidth: 1\n                }],\n                labels: rightDate\n              },\n              options: {\n                legend: {\n                  display: true,\n                  position: 'top',\n                  labels: {\n                    boxWidth: 50,\n                    fontColor: 'black'\n                  }\n                },\n                scales: {\n                  yAxes: [{\n                    ticks: {\n                      beginAtZero: true\n                    }\n                  }]\n                },\n                responsive: true,\n                maintainAspectRatio: false\n              }\n            });\n            return _context2.abrupt(\"return\", globalChartCreated);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function createGlobalChart() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nfullscreenChartBtn.addEventListener('click', function () {\n  if (!document.fullscreen) {\n    chart.requestFullscreen();\n    fullscreenChartBtn.style.top = '0.5rem';\n    fullscreenChartBtn.style.right = '0.5rem';\n  } else {\n    document.exitFullscreen();\n    fullscreenChartBtn.style.top = '-0.4rem';\n    fullscreenChartBtn.style.right = '-0.4rem';\n  }\n\n  ;\n});\nglobalCasesButton.addEventListener('click', function () {\n  return globalChartAction();\n});\ndailyCasesButton.addEventListener('click', function () {\n  return dailyChartAction();\n});\nhundredCasesButton.addEventListener('click', function () {\n  return hundredChartAction();\n});\nchartBtnContainer.addEventListener('click', function (event) {\n  return chartButtonActive(event);\n});\ncreateGlobalChart();\n// CONCATENATED MODULE: ./js/index.js\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvc2Nzcy9tYWluLnNjc3M/NmY2OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcz8xZGExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcz9hZGUzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvbWFwLmpzP2JhYmEiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy90YWJsZS5qcz82MzVlIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvbGlzdC5qcz9jMjIzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvY2hhcnQuanM/OGE3OCIsIndlYnBhY2s6Ly8vLi9qcy9pbmRleC5qcz9lZTFjIl0sIm5hbWVzIjpbImxlYWZsZXQiLCJ3aW5kb3ciLCJMIiwiY292aWRNYXAiLCJtYXAiLCJzZXRWaWV3IiwiaXNDb3ZpZEluZm8iLCJjb3ZpZENvbnRyb2wiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJhdHRyaWJ1dGlvbiIsInRpbGVMYXllclVybCIsInRpbGVzIiwidGlsZUxheWVyIiwiYWRkVG8iLCJjcmVhdGVNYXJrZXJVaSIsIndpZHRoIiwiaGVpZ2h0IiwiY292aWRNYXJrZXIiLCJpY29uIiwiaWNvblVybCIsImljb25TaXplIiwiaWNvbkFuY2hvciIsImNsYXNzTmFtZSIsImdlb0NvdmlkTWFya2VyIiwiY292aWRBcGlEYXRhIiwiZ2VvRm9ybWF0IiwidHlwZSIsImZlYXR1cmVzIiwiZWxlbWVudCIsImNvdW50cnlJbmZvIiwibGF0IiwibG9uZyIsImNhc2VzIiwiY292aWRJY29uIiwibWFya2VyIiwiY292aWRHZW9JbmYiLCJnZW9tZXRyeSIsImNvb3JkaW5hdGVzIiwicHJvcGVydGllcyIsImNyZWF0ZVBvcHVwQ292aWQiLCJnZW9GZWF0dXJlIiwiZ2VvSnNvblBvaW50IiwiR2VvSlNPTiIsInBvaW50VG9MYXllciIsInBvcHVsYXRpb24iLCJjb3VudHJ5IiwiZGVhdGhzIiwicmVjb3ZlcmVkIiwidG9kYXlDYXNlcyIsInRvZGF5RGVhdGhzIiwidG9kYXlSZWNvdmVyZWQiLCJjYXNlc1Blck9uZU1pbGxpb24iLCJyZWNvdmVyZWRQZXJPbmVNaWxsaW9uIiwiZGVhdGhzUGVyT25lTWlsbGlvbiIsImRpdkljb24iLCJodG1sIiwiTWF0aCIsInJvdW5kIiwicmlzZU9uSG92ZXIiLCJjb3ZpZERhdGEiLCJmZXRjaCIsInJlc3BvbnNlIiwianNvbiIsImNvdmlkQ29udHJvbEFjdGlvbiIsImV2ZW50IiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwic2xpY2UiLCJtYXJrZXJQb3B1cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYXJrZXJJbWciLCJhY3RpdmVCdG4iLCJmb3JFYWNoIiwiZWwiLCJyZW1vdmUiLCJjbGFzc0xpc3QiLCJhZGQiLCJhZGRDb250cm9sIiwiQ29udHJvbCIsIkZ1bGxzY3JlZW4iLCJhZGRFdmVudExpc3RlbmVyIiwiY291bnRyaWVzIiwidGFibGUiLCJmdWxsc2NyZWVuVGFibGVCdG4iLCJjb3VudHJ5RmxhZyIsImNvdW50cnlOYW1lIiwidGFibGVDb25maXJtZWQiLCJ0YWJsZURlYXRoIiwidGFibGVSZWNvdmVyZWQiLCJ0YWJsZVN3aXRoZXJEYXlzIiwiYXJyb3dMZWZ0RGF5cyIsInRhYmxlR2xvYmFsIiwidGFibGVEYWlseSIsImFycm93UmlnaHREYXlzIiwidGFibGVTd2l0aGVyQ291bnQiLCJhcnJvd0xlZnRDb3VudCIsInRhYmxlQWxsIiwidGFibGVQZXIxMDAiLCJhcnJvd1JpZ2h0Q291bnQiLCJ0b3RhbEJ0biIsImNvdW50cnlDYXNlc0RhdGEiLCJhbGxDYXNlc0RhdGEiLCJpc0dsb2JhbENhc2VzTW9kZSIsImlzQWxsQ2FzZXNNb2RlIiwiY3VycmVudENvdW50cnkiLCJjdXJyZW50Q291bnRyeURhdGEiLCJpc0NvdW50cnlNb2RlIiwid29ybGRQb3B1bGF0aW9uUGVyMTAwIiwiZ2V0RGF0YSIsInRoZW4iLCJyZXMiLCJnZXRJbmZvVGFibGUiLCJjb25maXJtZWQiLCJHbG9iYWwiLCJUb3RhbENvbmZpcm1lZCIsImRlYXRoIiwiVG90YWxEZWF0aHMiLCJUb3RhbFJlY292ZXJlZCIsIk5ld0NvbmZpcm1lZCIsIk5ld0RlYXRocyIsIk5ld1JlY292ZXJlZCIsImNyZWF0ZUNvdW50cnlUYWJsZSIsImdldEN1cnJlbnRDb3VudHJ5IiwiZmluZCIsImdldENvdW50cnlJbmZvIiwiZmxhZyIsImlubmVySFRNTCIsImlubmVyVGV4dCIsImNsZWFuVGFibGUiLCJjaGFuZ2VUYWJsZU5hbWVNb2RlIiwiZmlyc3RNb2RlIiwic2Vjb25kTW9kZSIsInRvZ2dsZSIsImNoYW5nZVRhYmxlQXJyb3dzIiwiZmlyc3RBcnJvdyIsInNlY29uZEFycm93IiwiZnVsbHNjcmVlbiIsInJlcXVlc3RGdWxsc2NyZWVuIiwic3R5bGUiLCJ0b3AiLCJyaWdodCIsImV4aXRGdWxsc2NyZWVuIiwiZnVsbHNjcmVlbkJ0biIsImxpc3QiLCJpbnB1dCIsImdldEVsZW1lbnRCeUlkIiwiZGF5c01vZGUiLCJjb3VudHNNb2RlIiwiZ2xvYmFsQ2FzZXMiLCJkYWlseUNhc2VzIiwiYWxsQ2FzZXMiLCJ0aG91c2FuZHNDYXNlcyIsImFycm93UmlnaHQiLCJhcnJvd0xlZnQiLCJrZXlib2FyZEJ0biIsImtleWJvYXJkQ29udGFpbmVyIiwidmlydHVhbEtleWJvYXJkIiwiREFUQSIsImNvdW50Q2xpY2tBcnJvdyIsImlzQ29uZmlybWVkTW9kZSIsImlzRGVhdGhDYXNlc01vZGUiLCJpc1JlY292ZXJlZE1vZGUiLCJzZWFyY2hUZXJtIiwiS2V5Ym9hcmQiLCJTaW1wbGVLZXlib2FyZCIsIm15S2V5Ym9hcmQiLCJvbkNoYW5nZSIsInVzZU1vdXNlRXZlbnRzIiwiZmV0Y2hEYXRhIiwic2VhY2hDb3VudHJpZXMiLCJmaWx0ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiZ2V0SW5mbyIsInNvcnQiLCJhIiwiYiIsImNyZWF0ZUNhcmRzIiwidG90YWxDb25maXJtZWRQZXIxMDAiLCJuZXdDb25maXJtZWRQZXIxMDAiLCJ0b3RhbERlYXRoc1BlcjEwMCIsIm5ld0RlYXRoc1BlcjEwMCIsInRvdGFsUmVjb3ZlcmVkUGVyMTAwIiwibmV3UmVjb3ZlcmVkUGVyMTAwIiwibnVtYmVycyIsImNvdW50cnlDb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiY291bnRyeUNhc2VzIiwiYXBwZW5kIiwidmFsdWUiLCJjaGFuZ2VTd2l0Y2hlck1vZGVCdG4iLCJjaGFuZ2VTd2l0Y2hlcnNEYXlzTW9kZSIsImNoYW5nZVN3aXRjaGVyc0Nhc2VzTW9kZSIsImtleWJvYXJkIiwic2V0SW5wdXQiLCJjaGFydEdsb2JhbCIsImdsb2JhbENhc2VzQnV0dG9uIiwid29ybGRDYXNlcyIsImNoYXJ0RGFpbHkiLCJkYWlseUNhc2VzQnV0dG9uIiwiY2hhcnRIdW5kcmVkIiwiaHVuZHJlZENhc2VzQnV0dG9uIiwiY2hhcnRCdG5Db250YWluZXIiLCJmdWxsc2NyZWVuQ2hhcnRCdG4iLCJjaGFydCIsImdsb2JhbENvbmZpcm1lZCIsImdsb2JhbERlYXRocyIsImdsb2JhbFJlY292ZXJlZCIsImRhdGVTdGFnZSIsInJpZ2h0RGF0ZSIsIm5ld0NvbmZpcm1lZCIsImxhc3REYXRlIiwibmV3UmVjb3ZlcmVkIiwibmV3RGVhdGhzIiwiZ2xvYmFsQ2hhcnRDcmVhdGVkIiwiZGFpbHlDaGFydENyZWF0ZWQiLCJodW5kcmVkQ2hhcnRDcmVhdGVkIiwiaXNTaG93Q2hhcnQiLCJpc0h1bmRyZWRDaGFydCIsImdsb2JhbEh1bmRyZWRDb25maXJtZWQiLCJnbG9iYWxIdW5kcmVkRGVhdGhzIiwiZ2xvYmFsSHVuZHJlZFJlY292ZXJlZCIsInRvZGF5SHVuZHJlZENvbmZpcm1lZCIsInRvZGF5SHVuZHJlZERlYXRocyIsInRvZGF5SHVuZHJlZFJlY292ZXJlZCIsIm1vbnRoc05hbWVzIiwiZm9ybWF0dGVkRGF0ZSIsInBhcnNlRGF0ZSIsImRhdGUiLCJEYXRlIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwic29ydERhdGEiLCJwdXNoIiwiZ2xvYmFsQ2hhcnRBY3Rpb24iLCJkYWlseUNoYXJ0QWN0aW9uIiwiY3JlYXRlRGFpbHlDaGFydCIsIkNoYXJ0IiwiZGF0YSIsImRhdGFzZXRzIiwibGFiZWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJsYWJlbHMiLCJvcHRpb25zIiwidGl0bGUiLCJkaXNwbGF5IiwidGV4dCIsInJlc3BvbnNpdmUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwiaHVuZHJlZENoYXJ0QWN0aW9uIiwiY3JlYXRlSHVuZHJlZENoYXJ0IiwiZmlsbCIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJsZWdlbmQiLCJwb3NpdGlvbiIsImJveFdpZHRoIiwiZm9udFNpemUiLCJmb250Q29sb3IiLCJuZXdfY29uZmlybWVkIiwibmV3X2RlYXRocyIsIm5ld19yZWNvdmVyZWQiLCJjaGFydEJ1dHRvbkFjdGl2ZSIsInRhcmdldEJ0biIsImNyZWF0ZUdsb2JhbENoYXJ0Iiwic2NhbGVzIiwieUF4ZXMiLCJ0aWNrcyIsImJlZ2luQXRaZXJvIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDOztBQ2xDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEM7Ozs7Ozs7Ozs7QUNiQSxJQUFNQSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsQ0FBdkI7QUFDQSxJQUFNQyxRQUFRLEdBQUdILE9BQU8sQ0FBQ0ksR0FBUixDQUFZ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QUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiY29uc3QgbGVhZmxldCA9IHdpbmRvdy5MO1xuY29uc3QgY292aWRNYXAgPSBsZWFmbGV0Lm1hcCgnbWFwaWQnKS5zZXRWaWV3KFswLCAwXSwgMik7XG5cbmxldCBpc0NvdmlkSW5mbyA9IHRydWU7XG5jb25zdCBjb3ZpZENvbnRyb2wgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFwX19jb250cm9sJyk7XG5cbmNvbnN0IGF0dHJpYnV0aW9uID0gJyZjb3B5OyA8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gY29udHJpYnV0b3JzJztcblxuY29uc3QgdGlsZUxheWVyVXJsID0gJ2h0dHBzOi8vY2FydG9kYi1iYXNlbWFwcy17c30uZ2xvYmFsLnNzbC5mYXN0bHkubmV0L2xpZ2h0X2FsbC97en0ve3h9L3t5fS5wbmcnO1xuY29uc3QgdGlsZXMgPSBsZWFmbGV0LnRpbGVMYXllcih0aWxlTGF5ZXJVcmwsIHsgYXR0cmlidXRpb24gfSk7XG50aWxlcy5hZGRUbyhjb3ZpZE1hcCk7XG5cbmNvbnN0IGNyZWF0ZU1hcmtlclVpID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgY29uc3QgY292aWRNYXJrZXIgPSBsZWFmbGV0Lmljb24oe1xuICAgIGljb25Vcmw6IGlzQ292aWRJbmZvID8gJy4uL2Fzc2V0cy9pbWFnZXMvY292aWQtbWFya2VyMS5wbmcnIDogJy4uL2Fzc2V0cy9pbWFnZXMvY292aWQtbWFya2VyMi5wbmcnLFxuICAgIGljb25TaXplOiBbd2lkdGgsIGhlaWdodF0sXG4gICAgaWNvbkFuY2hvcjogWzI1LCAxNl0sXG4gICAgY2xhc3NOYW1lOiAnbWFya2VyX2ltZycsXG4gIH0pO1xuXG4gIHJldHVybiBjb3ZpZE1hcmtlcjtcbn07XG5cbmNvbnN0IGdlb0NvdmlkTWFya2VyID0gKGNvdmlkQXBpRGF0YSkgPT4ge1xuICBjb25zdCBnZW9Gb3JtYXQgPSB7XG4gICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICBmZWF0dXJlczogY292aWRBcGlEYXRhLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgeyBjb3VudHJ5SW5mbyB9ID0gZWxlbWVudDtcbiAgICAgIGNvbnN0IHsgbGF0LCBsb25nIH0gPSBjb3VudHJ5SW5mbztcblxuICAgICAgaWYgKGVsZW1lbnQuY2FzZXMgPiA0MDAwMDAgJiYgZWxlbWVudC5jYXNlcyA8IDkwMDAwMCkge1xuICAgICAgICBjb25zdCBjb3ZpZEljb24gPSBjcmVhdGVNYXJrZXJVaSg2MCwgNTApO1xuXG4gICAgICAgIGxlYWZsZXQubWFya2VyKFtsYXQsIGxvbmddLCB7IGljb246IGNvdmlkSWNvbiB9KS5hZGRUbyhjb3ZpZE1hcCk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5jYXNlcyA8IDQwMDAwMCkge1xuICAgICAgICBjb25zdCBjb3ZpZEljb24gPSBjcmVhdGVNYXJrZXJVaSgyMCwgMTUpO1xuXG4gICAgICAgIGxlYWZsZXQubWFya2VyKFtsYXQsIGxvbmddLCB7IGljb246IGNvdmlkSWNvbiB9KS5hZGRUbyhjb3ZpZE1hcCk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5jYXNlcyA+IDkwMDAwMCkge1xuICAgICAgICBjb25zdCBjb3ZpZEljb24gPSBjcmVhdGVNYXJrZXJVaSgxMDAsIDkwKTtcblxuICAgICAgICBsZWFmbGV0Lm1hcmtlcihbbGF0LCBsb25nXSwgeyBpY29uOiBjb3ZpZEljb24gfSkuYWRkVG8oY292aWRNYXApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3ZpZEdlb0luZiA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFtsb25nLCBsYXRdLFxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjb3ZpZEdlb0luZjtcbiAgICB9KSxcbiAgfTtcblxuICByZXR1cm4gZ2VvRm9ybWF0O1xufTtcblxuY29uc3QgY3JlYXRlUG9wdXBDb3ZpZCA9IChnZW9GZWF0dXJlKSA9PiB7XG4gIGNvbnN0IGdlb0pzb25Qb2ludCA9IG5ldyBsZWFmbGV0Lkdlb0pTT04oZ2VvRmVhdHVyZSwge1xuICAgIHBvaW50VG9MYXllcjogKGNvdmlkR2VvSW5mLCBjb29yZGluYXRlcykgPT4ge1xuICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBjb3ZpZEdlb0luZjtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBwb3B1bGF0aW9uLFxuICAgICAgICBjb3VudHJ5LFxuICAgICAgICBjYXNlcyxcbiAgICAgICAgZGVhdGhzLFxuICAgICAgICByZWNvdmVyZWQsXG4gICAgICAgIHRvZGF5Q2FzZXMsXG4gICAgICAgIHRvZGF5RGVhdGhzLFxuICAgICAgICB0b2RheVJlY292ZXJlZCxcbiAgICAgICAgY2FzZXNQZXJPbmVNaWxsaW9uLFxuICAgICAgICByZWNvdmVyZWRQZXJPbmVNaWxsaW9uLFxuICAgICAgICBkZWF0aHNQZXJPbmVNaWxsaW9uLFxuICAgICAgfSA9IHByb3BlcnRpZXM7XG5cbiAgICAgIGNvbnN0IG1hcmtlciA9IGxlYWZsZXQubWFya2VyKGNvb3JkaW5hdGVzLCB7XG4gICAgICAgIGljb246IGxlYWZsZXQuZGl2SWNvbih7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnbWFya2VyUG9wdXAnLFxuICAgICAgICAgIGh0bWw6IGAke2lzQ292aWRJbmZvXG4gICAgICAgICAgICA/IGA8ZGl2IGNsYXNzPVwiY292aWRfX2NvbnRhaW5lclwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY292aWRfX2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8aDIgY2xhc3M9XCJjb3ZpZF9fY291bnRyeVwiPiR7Y291bnRyeX06PC9oMj5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgPHNwYW4+PGgzIGNsYXNzPVwiY292aWRfX2luZm9cIj5Qb3B1bGF0aW9uOiAke3BvcHVsYXRpb259IDwvaDM+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+PGgzIGNsYXNzPVwiY292aWRfX2luZm9cIj5Ub3RhbENvbmZpcm1lZDogJHtjYXNlc30gPC9oMz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj48aDMgY2xhc3M9XCJjb3ZpZF9faW5mb1wiPlRvdGFsRGVhdGhzOiAke2RlYXRoc308L2gzPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuPjxoMyBjbGFzcz1cImNvdmlkX19pbmZvXCI+VG90YWxSZWNvdmVyZWQ6ICR7cmVjb3ZlcmVkfTwvaDM+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmBcbiAgICAgICAgICAgIDogYDxkaXYgY2xhc3M9XCJjb3ZpZF9fY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb3ZpZF9fY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cImNvdmlkX19jb3VudHJ5XCI+JHtjb3VudHJ5fTo8L2gyPlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj48aDMgY2xhc3M9XCJjb3ZpZF9faW5mb1wiPlRvZGF5Q29uZmlybWVkOiAke3RvZGF5Q2FzZXN9IDwvaDM+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+PGgzIGNsYXNzPVwiY292aWRfX2luZm9cIj5Ub2RheURlYXRoczogJHt0b2RheURlYXRoc30gPC9oMz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj48aDMgY2xhc3M9XCJjb3ZpZF9faW5mb1wiPlRvZGF5UmVjb3ZlcmVkOiAke3RvZGF5UmVjb3ZlcmVkfSA8L2gzPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuPjxoMyBjbGFzcz1cImNvdmlkX19pbmZvXCI+UGVyMTAwIENvcmZpcm1lZDogJHtNYXRoLnJvdW5kKGNhc2VzUGVyT25lTWlsbGlvbiAvIDEwKX0gPC9oMz48L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj48aDMgY2xhc3M9XCJjb3ZpZF9faW5mb1wiPlBlcjEwMCBSZWNvdmVyZWQ6ICR7TWF0aC5yb3VuZChyZWNvdmVyZWRQZXJPbmVNaWxsaW9uIC8gMTApfSA8L2gzPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuPjxoMyBjbGFzcz1cImNvdmlkX19pbmZvXCI+UGVyMTAwIERlYXRoczogJHtNYXRoLnJvdW5kKGRlYXRoc1Blck9uZU1pbGxpb24gLyAxMCl9IDwvaDM+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmB9YCxcbiAgICAgICAgfSksXG4gICAgICAgIHJpc2VPbkhvdmVyOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfSxcbiAgfSk7XG5cbiAgZ2VvSnNvblBvaW50LmFkZFRvKGNvdmlkTWFwKTtcbn07XG5cbmNvbnN0IGNvdmlkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9jb3JvbmEubG1hby5uaW5qYS92Mi9jb3VudHJpZXMnKTtcbiAgY29uc3QgY292aWRBcGlEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gIGNvbnN0IGdlb0ZlYXR1cmUgPSBnZW9Db3ZpZE1hcmtlcihjb3ZpZEFwaURhdGEpO1xuICBjcmVhdGVQb3B1cENvdmlkKGdlb0ZlYXR1cmUpO1xufTtcblxuY29uc3QgY292aWRDb250cm9sQWN0aW9uID0gKGV2ZW50KSA9PiB7XG4gIGlmIChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNsaWNlKC03KSA9PT0gJ2NvbnRyb2wnKSByZXR1cm47XG4gIGNvbnN0IG1hcmtlclBvcHVwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1hcmtlclBvcHVwJyk7XG4gIGNvbnN0IG1hcmtlckltZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tYXJrZXJfaW1nJyk7XG4gIGNvbnN0IGFjdGl2ZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hY3R1YWwnKTtcblxuICBtYXJrZXJJbWcuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBlbC5yZW1vdmUoKTtcbiAgfSk7XG4gIG1hcmtlclBvcHVwLmZvckVhY2goKGVsKSA9PiB7XG4gICAgZWwucmVtb3ZlKCk7XG4gIH0pO1xuXG4gIGlmIChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNsaWNlKC01KSA9PT0gJ3RvdGFsJykge1xuICAgIGlzQ292aWRJbmZvID0gdHJ1ZTtcbiAgICBjb3ZpZERhdGEoKTtcbiAgfVxuXG4gIGlmIChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNsaWNlKC01KSA9PT0gJ3RvZGF5Jykge1xuICAgIGlzQ292aWRJbmZvID0gZmFsc2U7XG4gICAgY292aWREYXRhKCk7XG4gIH1cblxuICBpZiAoYWN0aXZlQnRuICE9PSBudWxsKSB7XG4gICAgYWN0aXZlQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdHVhbCcpO1xuICB9XG4gIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3R1YWwnKTtcbn07XG5cbmNvdmlkTWFwLmFkZENvbnRyb2wobmV3IGxlYWZsZXQuQ29udHJvbC5GdWxsc2NyZWVuKCkpO1xuXG5jb3ZpZERhdGEoKTtcblxuY292aWRDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiBjb3ZpZENvbnRyb2xBY3Rpb24oZXZlbnQpKTtcbiIsImNvbnN0IGNvdW50cmllcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3VudHJpZXMnKTtcbmNvbnN0IHRhYmxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy50YWJsZScpO1xuY29uc3QgZnVsbHNjcmVlblRhYmxlQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy5mdWxsc2NyZWVuX190YWJsZScpO1xuXG5jb25zdCBjb3VudHJ5RmxhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3VudHJ5X19mbGFnJyk7XG5jb25zdCBjb3VudHJ5TmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3VudHJ5X19uYW1lJyk7XG5cbmNvbnN0IHRhYmxlQ29uZmlybWVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhYmxlX19jb25maXJtZWQnKTtcbmNvbnN0IHRhYmxlRGVhdGggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFibGVfX2RlYXRoJyk7XG5jb25zdCB0YWJsZVJlY292ZXJlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWJsZV9fcmVjb3ZlcmVkJyk7XG5cbmNvbnN0IHRhYmxlU3dpdGhlckRheXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFibGVfX3N3aXRoZXJfZGF5cycpO1xuY29uc3QgYXJyb3dMZWZ0RGF5cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hcnJvd19fbGVmdF9kYXlzJyk7XG5jb25zdCB0YWJsZUdsb2JhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWJsZV9fZ2xvYmFsJyk7XG5jb25zdCB0YWJsZURhaWx5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRhYmxlX19kYWlseScpO1xuY29uc3QgYXJyb3dSaWdodERheXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJyb3dfX3JpZ2h0X2RheXMnKTtcblxuY29uc3QgdGFibGVTd2l0aGVyQ291bnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGFibGVfX3N3aXRoZXJfY291bnQnKTtcbmNvbnN0IGFycm93TGVmdENvdW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFycm93X19sZWZ0X2NvdW50Jyk7XG5jb25zdCB0YWJsZUFsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWJsZV9fYWxsJyk7XG5jb25zdCB0YWJsZVBlcjEwMCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50YWJsZV9fcGVyMTAwJyk7XG5jb25zdCBhcnJvd1JpZ2h0Q291bnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJyb3dfX3JpZ2h0X2NvdW50Jyk7XG5cbmNvbnN0IHRvdGFsQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvdGFsX19idG4nKTtcblxubGV0IGNvdW50cnlDYXNlc0RhdGE7XG5sZXQgYWxsQ2FzZXNEYXRhO1xubGV0IGlzR2xvYmFsQ2FzZXNNb2RlID0gdHJ1ZTtcbmxldCBpc0FsbENhc2VzTW9kZSA9IHRydWU7XG5sZXQgY3VycmVudENvdW50cnk7XG5sZXQgY3VycmVudENvdW50cnlEYXRhO1xubGV0IGlzQ291bnRyeU1vZGU7XG5jb25zdCB3b3JsZFBvcHVsYXRpb25QZXIxMDAgPSA3ODI3MDtcblxuY29uc3QgZ2V0RGF0YSA9IGFzeW5jICgpID0+IHtcbiAgY291bnRyeUNhc2VzRGF0YSA9IGF3YWl0IGZldGNoKCdodHRwczovL2Nvcm9uYS5sbWFvLm5pbmphL3YyL2NvdW50cmllcycpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpO1xuICBhbGxDYXNlc0RhdGEgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuY292aWQxOWFwaS5jb20vc3VtbWFyeScpLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpOyAgICAgICAgICBcbn07XG5cbmNvbnN0IGdldEluZm9UYWJsZSA9IGFzeW5jICgpID0+IHtcblxuICBhd2FpdCBnZXREYXRhKCk7XG5cbiAgaWYoaXNDb3VudHJ5TW9kZSkgcmV0dXJuO1xuXG4gIGxldCBjb25maXJtZWQ7XG4gIGxldCBkZWF0aDtcbiAgbGV0IHJlY292ZXJlZDtcblxuICBpZiAoaXNHbG9iYWxDYXNlc01vZGUgJiYgaXNBbGxDYXNlc01vZGUpIHtcbiAgICBjb25maXJtZWQgPSBhbGxDYXNlc0RhdGEuR2xvYmFsLlRvdGFsQ29uZmlybWVkO1xuICAgIGRlYXRoID0gYWxsQ2FzZXNEYXRhLkdsb2JhbC5Ub3RhbERlYXRocztcbiAgICByZWNvdmVyZWQgPSBhbGxDYXNlc0RhdGEuR2xvYmFsLlRvdGFsUmVjb3ZlcmVkO1xuICB9XG5cbiAgZWxzZSBpZiAoIWlzR2xvYmFsQ2FzZXNNb2RlICYmIGlzQWxsQ2FzZXNNb2RlKSB7XG4gICAgY29uZmlybWVkID0gYWxsQ2FzZXNEYXRhLkdsb2JhbC5OZXdDb25maXJtZWQ7XG4gICAgZGVhdGggPSBhbGxDYXNlc0RhdGEuR2xvYmFsLk5ld0RlYXRocztcbiAgICByZWNvdmVyZWQgPSBhbGxDYXNlc0RhdGEuR2xvYmFsLk5ld1JlY292ZXJlZDtcbiAgfVxuXG4gIGVsc2UgaWYgKGlzR2xvYmFsQ2FzZXNNb2RlICYmICFpc0FsbENhc2VzTW9kZSkge1xuICAgIGNvbmZpcm1lZCA9IE1hdGgucm91bmQoYWxsQ2FzZXNEYXRhLkdsb2JhbC5Ub3RhbENvbmZpcm1lZCAvIHdvcmxkUG9wdWxhdGlvblBlcjEwMCk7XG4gICAgZGVhdGggPSBNYXRoLnJvdW5kKGFsbENhc2VzRGF0YS5HbG9iYWwuVG90YWxEZWF0aHMgLyB3b3JsZFBvcHVsYXRpb25QZXIxMDApO1xuICAgIHJlY292ZXJlZCA9IE1hdGgucm91bmQoYWxsQ2FzZXNEYXRhLkdsb2JhbC5Ub3RhbFJlY292ZXJlZCAvIHdvcmxkUG9wdWxhdGlvblBlcjEwMCk7XG4gIH1cblxuICBlbHNlIGlmICghaXNHbG9iYWxDYXNlc01vZGUgJiYgIWlzQWxsQ2FzZXNNb2RlKSB7XG4gICAgY29uZmlybWVkID0gTWF0aC5yb3VuZChhbGxDYXNlc0RhdGEuR2xvYmFsLk5ld0NvbmZpcm1lZCAvIHdvcmxkUG9wdWxhdGlvblBlcjEwMCk7XG4gICAgZGVhdGggPSBNYXRoLnJvdW5kKGFsbENhc2VzRGF0YS5HbG9iYWwuTmV3RGVhdGhzIC8gd29ybGRQb3B1bGF0aW9uUGVyMTAwKTtcbiAgICByZWNvdmVyZWQgPSBNYXRoLnJvdW5kKGFsbENhc2VzRGF0YS5HbG9iYWwuTmV3UmVjb3ZlcmVkIC8gd29ybGRQb3B1bGF0aW9uUGVyMTAwKTtcbiAgfVxuXG4gIGNyZWF0ZUNvdW50cnlUYWJsZSgnV29ybGQnLCAnYXNzZXRzL2ltYWdlcy93b3JsZC1pY29uLnBuZycsIGNvbmZpcm1lZCwgZGVhdGgsIHJlY292ZXJlZCk7XG59O1xuXG5jb25zdCBnZXRDdXJyZW50Q291bnRyeSA9ICgpID0+IHtcbiAgY3VycmVudENvdW50cnlEYXRhID0gY291bnRyeUNhc2VzRGF0YS5maW5kKGNvdW50cnkgPT4gY3VycmVudENvdW50cnkgPT09IGNvdW50cnkuY291bnRyeSk7XG59O1xuXG5jb25zdCBnZXRDb3VudHJ5SW5mbyA9IGFzeW5jICgpID0+IHtcbiAgYXdhaXQgZ2V0RGF0YSgpO1xuXG4gIGlmKCFpc0NvdW50cnlNb2RlKSByZXR1cm47XG5cbiAgbGV0IGNvbmZpcm1lZDtcbiAgbGV0IGRlYXRoO1xuICBsZXQgcmVjb3ZlcmVkO1xuXG4gIGlmIChpc0dsb2JhbENhc2VzTW9kZSAmJiBpc0FsbENhc2VzTW9kZSkge1xuICAgIGNvbmZpcm1lZCA9IGN1cnJlbnRDb3VudHJ5RGF0YS5jYXNlcztcbiAgICBkZWF0aCA9IGN1cnJlbnRDb3VudHJ5RGF0YS5kZWF0aHM7XG4gICAgcmVjb3ZlcmVkID0gY3VycmVudENvdW50cnlEYXRhLnJlY292ZXJlZDtcbiAgfVxuXG4gIGVsc2UgaWYgKCFpc0dsb2JhbENhc2VzTW9kZSAmJiBpc0FsbENhc2VzTW9kZSkge1xuICAgIGNvbmZpcm1lZCA9IGN1cnJlbnRDb3VudHJ5RGF0YS50b2RheUNhc2VzO1xuICAgIGRlYXRoID0gY3VycmVudENvdW50cnlEYXRhLnRvZGF5RGVhdGhzO1xuICAgIHJlY292ZXJlZCA9IGN1cnJlbnRDb3VudHJ5RGF0YS50b2RheVJlY292ZXJlZDtcbiAgfVxuXG4gIGVsc2UgaWYgKGlzR2xvYmFsQ2FzZXNNb2RlICYmICFpc0FsbENhc2VzTW9kZSkge1xuICAgIGNvbmZpcm1lZCA9IE1hdGgucm91bmQoY3VycmVudENvdW50cnlEYXRhLmNhc2VzUGVyT25lTWlsbGlvbiAvIDEwKTtcbiAgICBkZWF0aCA9IE1hdGgucm91bmQoY3VycmVudENvdW50cnlEYXRhLmRlYXRoc1Blck9uZU1pbGxpb24gLyAxMCk7XG4gICAgcmVjb3ZlcmVkID0gTWF0aC5yb3VuZChjdXJyZW50Q291bnRyeURhdGEucmVjb3ZlcmVkUGVyT25lTWlsbGlvbiAvIDEwKTtcbiAgfVxuXG4gIGVsc2UgaWYgKCFpc0dsb2JhbENhc2VzTW9kZSAmJiAhaXNBbGxDYXNlc01vZGUpIHtcbiAgICBjb25maXJtZWQgPSBNYXRoLnJvdW5kKGN1cnJlbnRDb3VudHJ5RGF0YS50b2RheUNhc2VzIC8gY3VycmVudENvdW50cnlEYXRhLnBvcHVsYXRpb24gKiAxMDAwMDApO1xuICAgIGRlYXRoID0gTWF0aC5yb3VuZChjdXJyZW50Q291bnRyeURhdGEudG9kYXlEZWF0aHMgLyBjdXJyZW50Q291bnRyeURhdGEucG9wdWxhdGlvbiAqIDEwMDAwMCk7XG4gICAgcmVjb3ZlcmVkID0gTWF0aC5yb3VuZChjdXJyZW50Q291bnRyeURhdGEudG9kYXlSZWNvdmVyZWQgLyBjdXJyZW50Q291bnRyeURhdGEucG9wdWxhdGlvbiAqIDEwMDAwMCk7XG4gIH1cblxuICBjcmVhdGVDb3VudHJ5VGFibGUoY3VycmVudENvdW50cnlEYXRhLmNvdW50cnksIGN1cnJlbnRDb3VudHJ5RGF0YS5jb3VudHJ5SW5mby5mbGFnLCBjb25maXJtZWQsIGRlYXRoLCByZWNvdmVyZWQpO1xuXG59XG5cbmNvbnN0IGNyZWF0ZUNvdW50cnlUYWJsZSA9IChjb3VudHJ5LCBmbGFnLCBjb25maXJtZWQsIGRlYXRoLCByZWNvdmVyZWQpID0+IHtcbiAgY291bnRyeUZsYWcuaW5uZXJIVE1MID0gYDxpbWcgc3JjPVwiLi4vJHtmbGFnfVwiIGNsYXNzPVwiZmxhZ19faW1nXCI+YDtcbiAgY291bnRyeU5hbWUuaW5uZXJUZXh0ID0gY291bnRyeTtcblxuICB0YWJsZUNvbmZpcm1lZC5pbm5lclRleHQgPSBjb25maXJtZWQ7XG4gIHRhYmxlRGVhdGguaW5uZXJUZXh0ID0gZGVhdGg7XG4gIHRhYmxlUmVjb3ZlcmVkLmlubmVyVGV4dCA9IHJlY292ZXJlZDtcbn07XG5cbi8vY2xlYW4gbnVtYmVyc1xuY29uc3QgY2xlYW5UYWJsZSA9ICgpID0+IHtcbiAgdGFibGVDb25maXJtZWQuaW5uZXJIVE1MID0gJyc7XG4gIHRhYmxlRGVhdGguaW5uZXJIVE1MID0gJyc7XG4gIHRhYmxlUmVjb3ZlcmVkLmlubmVySFRNTCA9ICcnO1xufTtcblxuY29uc3QgY2hhbmdlVGFibGVOYW1lTW9kZSA9IChmaXJzdE1vZGUsIHNlY29uZE1vZGUpID0+IHtcbiAgZmlyc3RNb2RlLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGUnKTtcbiAgc2Vjb25kTW9kZS5jbGFzc0xpc3QudG9nZ2xlKCdoaWRlJyk7XG59XG5cbmNvbnN0IGNoYW5nZVRhYmxlQXJyb3dzID0gKGZpcnN0QXJyb3csIHNlY29uZEFycm93KSA9PiB7XG4gIGZpcnN0QXJyb3cuY2xhc3NMaXN0LnRvZ2dsZSgndW5hY3RpdmUnKTtcbiAgc2Vjb25kQXJyb3cuY2xhc3NMaXN0LnRvZ2dsZSgndW5hY3RpdmUnKTtcbn07XG5cbi8vZGF5cyBzd2l0aGVyIHJpZ2h0XG5hcnJvd1JpZ2h0RGF5cy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgXG4gIGlmKGlzR2xvYmFsQ2FzZXNNb2RlKSB7XG4gICAgY2hhbmdlVGFibGVOYW1lTW9kZSh0YWJsZUdsb2JhbCwgdGFibGVEYWlseSk7XG4gICAgY2hhbmdlVGFibGVBcnJvd3MoYXJyb3dMZWZ0RGF5cywgYXJyb3dSaWdodERheXMpO1xuICAgIGlzR2xvYmFsQ2FzZXNNb2RlID0gZmFsc2U7XG4gIH1cblxuICBjbGVhblRhYmxlKCk7XG4gIGdldEluZm9UYWJsZSgpO1xuICBnZXRDb3VudHJ5SW5mbygpO1xufSk7XG5cbi8vZGF5cyBzd2l0aGVyIGxlZnRcbmFycm93TGVmdERheXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cbiAgaWYoIWlzR2xvYmFsQ2FzZXNNb2RlKSB7XG4gICAgY2hhbmdlVGFibGVOYW1lTW9kZSh0YWJsZUdsb2JhbCwgdGFibGVEYWlseSk7XG4gICAgY2hhbmdlVGFibGVBcnJvd3MoYXJyb3dMZWZ0RGF5cywgYXJyb3dSaWdodERheXMpO1xuICAgIFxuICAgIGlzR2xvYmFsQ2FzZXNNb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIGNsZWFuVGFibGUoKTtcbiAgZ2V0SW5mb1RhYmxlKCk7XG4gIGdldENvdW50cnlJbmZvKCk7XG59KTtcblxuLy9jb3VudCBzd2l0aGVyIHJpZ2h0XG5hcnJvd1JpZ2h0Q291bnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cbiAgaWYoaXNBbGxDYXNlc01vZGUpIHtcbiAgICBjaGFuZ2VUYWJsZU5hbWVNb2RlKHRhYmxlQWxsLCB0YWJsZVBlcjEwMCk7XG4gICAgY2hhbmdlVGFibGVBcnJvd3MoYXJyb3dMZWZ0Q291bnQsIGFycm93UmlnaHRDb3VudCk7XG4gICAgaXNBbGxDYXNlc01vZGUgPSBmYWxzZTtcbiAgfVxuXG4gIGNsZWFuVGFibGUoKTtcbiAgZ2V0SW5mb1RhYmxlKCk7XG4gIGdldENvdW50cnlJbmZvKCk7XG59KTtcblxuLy9jb3VudCBzd2l0aGVyIGxlZnRcbmFycm93TGVmdENvdW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXG4gIGlmKCFpc0FsbENhc2VzTW9kZSkge1xuICAgIGNoYW5nZVRhYmxlTmFtZU1vZGUodGFibGVBbGwsIHRhYmxlUGVyMTAwKTtcbiAgICBjaGFuZ2VUYWJsZUFycm93cyhhcnJvd0xlZnRDb3VudCwgYXJyb3dSaWdodENvdW50KTtcbiAgICBpc0FsbENhc2VzTW9kZSA9IHRydWU7XG4gIH1cblxuICBjbGVhblRhYmxlKCk7XG4gIGdldEluZm9UYWJsZSgpO1xuICBnZXRDb3VudHJ5SW5mbygpO1xufSk7XG5cbi8vY2hvb3NlIGNvdW50cnkgZm9yIHRhYmxlXG5jb3VudHJpZXMuYWRkRXZlbnRMaXN0ZW5lciAoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gIGNsZWFuVGFibGUoKTtcbiAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICBpZiAodGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ2NvdW50cnlfX25hbWUnKSB7XG4gICAgY3VycmVudENvdW50cnkgPSBjdXJyZW50Q291bnRyeTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50Q291bnRyeSA9IHRhcmdldC5pbm5lclRleHQ7XG4gIH1cbiAgaXNDb3VudHJ5TW9kZSA9IHRydWU7XG5cbiAgZ2V0Q3VycmVudENvdW50cnkoKTsgXG4gIGdldENvdW50cnlJbmZvKCk7XG59KTtcblxuLy9yZXR1cm4gdG8gdG90YWwgY2FzZXNcbnRvdGFsQnRuLmFkZEV2ZW50TGlzdGVuZXIgKCdjbGljaycsICgpID0+IHtcbiAgaXNDb3VudHJ5TW9kZSA9IGZhbHNlO1xuICBjbGVhblRhYmxlKCk7XG4gIGdldEluZm9UYWJsZSgpO1xufSk7XG5cbi8vYWRkIGZ1bGwgU2NyZWVuXG5mdWxsc2NyZWVuVGFibGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmKCFkb2N1bWVudC5mdWxsc2NyZWVuKSB7XG4gICAgdGFibGUucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICBmdWxsc2NyZWVuVGFibGVCdG4uc3R5bGUudG9wID0gJzAuNXJlbSc7XG4gICAgZnVsbHNjcmVlblRhYmxlQnRuLnN0eWxlLnJpZ2h0ID0gJzAuNXJlbSc7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICBmdWxsc2NyZWVuVGFibGVCdG4uc3R5bGUudG9wID0gJy0wLjRyZW0nO1xuICAgIGZ1bGxzY3JlZW5UYWJsZUJ0bi5zdHlsZS5yaWdodCA9ICctMC40cmVtJztcbiAgfTtcbn0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICgnRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgZ2V0SW5mb1RhYmxlKCk7XG59KTtcbiIsIlxuY29uc3QgZnVsbHNjcmVlbkJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKCcuZnVsbHNjcmVlbl9fbGlzdCcpO1xuY29uc3QgbGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKCcubGlzdCcpO1xuXG5jb25zdCBjb3VudHJpZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY291bnRyaWVzJyk7XG5jb25zdCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2gnKTtcblxuY29uc3QgZGF5c01vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGF5c19fbW9kZScpO1xuY29uc3QgY291bnRzTW9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb3VudHNfX21vZGUnKTtcbmNvbnN0IGdsb2JhbENhc2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmdsb2JhbF9fY2FzZXMnKTtcbmNvbnN0IGRhaWx5Q2FzZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGFpbHlfX2Nhc2VzJyk7XG5jb25zdCBhbGxDYXNlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbGxfX2Nhc2VzJyk7XG5jb25zdCB0aG91c2FuZHNDYXNlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50aG91c2FuZHNfX2Nhc2VzJyk7XG5cbmNvbnN0IGFycm93UmlnaHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICgnLmFycm93X19yaWdodF9saXN0Jyk7XG5jb25zdCBhcnJvd0xlZnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICgnLmFycm93X19sZWZ0X2xpc3QnKTtcbmNvbnN0IGNvbmZpcm1lZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKCcuY29uZmlybWVkJyk7XG5jb25zdCBkZWF0aHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICgnLmRlYXRocycpO1xuY29uc3QgcmVjb3ZlcmVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy5yZWNvdmVyZWQnKTtcblxuY29uc3Qga2V5Ym9hcmRCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICgnLmtleWJvYXJkX19idG4nKTtcbmNvbnN0IGtleWJvYXJkQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy5rZXlib2FyZENvbnRhaW5lcicpO1xuY29uc3QgdmlydHVhbEtleWJvYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy52aXJ0dWFsX19rZXlib2FyZCcpO1xuXG5cbmxldCBEQVRBO1xubGV0IGlzR2xvYmFsQ2FzZXNNb2RlID0gdHJ1ZTtcbmxldCBpc0FsbENhc2VzTW9kZSA9IHRydWU7XG5sZXQgY291bnRDbGlja0Fycm93ID0gMDtcbmxldCBpc0NvbmZpcm1lZE1vZGUgPSB0cnVlO1xubGV0IGlzRGVhdGhDYXNlc01vZGUgPSBmYWxzZTtcbmxldCBpc1JlY292ZXJlZE1vZGUgPSBmYWxzZTtcbmxldCBzZWFyY2hUZXJtID0gJyc7XG5cbmxldCBLZXlib2FyZCA9IHdpbmRvdy5TaW1wbGVLZXlib2FyZC5kZWZhdWx0O1xuXG5sZXQgbXlLZXlib2FyZCA9IG5ldyBLZXlib2FyZCh7XG4gIG9uQ2hhbmdlOiBpbnB1dCA9PiBvbkNoYW5nZShpbnB1dCksXG5cbiAgdXNlTW91c2VFdmVudHM6IHRydWUsXG59KTtcblxuY29uc3QgZmV0Y2hEYXRhID0gYXN5bmMgKCkgPT4ge1xuICBEQVRBID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vY29yb25hLmxtYW8ubmluamEvdjIvY291bnRyaWVzJylcbiAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7ICAgICAgICAgICAgICAgICBcbn07XG5cbmNvbnN0IHNlYWNoQ291bnRyaWVzID0gKCkgPT4ge1xuICBEQVRBID0gREFUQS5maWx0ZXIoKGNvdW50cnkpID0+IGNvdW50cnkuY291bnRyeS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkpO1xufVxuXG5jb25zdCBnZXRJbmZvID0gYXN5bmMgKCkgPT4ge1xuXG4gIGF3YWl0IGZldGNoRGF0YSgpO1xuICBzZWFjaENvdW50cmllcygpO1xuXG4gIERBVEEuZm9yRWFjaCgoY291bnRyeSkgPT4ge1xuICAgIGlmIChjb3VudHJ5LmNvdW50cnkgPT09ICdNUyBaYWFuZGFtJykge1xuICAgICAgY291bnRyeS5wb3B1bGF0aW9uID0gNzY4MDQ7XG4gICAgfVxuICAgIGlmIChjb3VudHJ5LmNvdW50cnkgPT09ICdEaWFtb25kIFByaW5jZXNzJykge1xuICAgICAgY291bnRyeS5wb3B1bGF0aW9uID0gMjg2NzA7XG4gICAgfVxuICB9KTtcblxuXG5cbiAgaWYoaXNHbG9iYWxDYXNlc01vZGUgJiYgaXNBbGxDYXNlc01vZGUgJiYgaXNDb25maXJtZWRNb2RlKSB7XG4gICAgREFUQS5zb3J0KChhLCBiKSA9PiBhLmNhc2VzIDwgYi5jYXNlcyA/IDEgOiAtMSk7XG4gICAgREFUQS5mb3JFYWNoKChjb3VudHJ5KSA9PiBjcmVhdGVDYXJkcyhjb3VudHJ5LCBjb3VudHJ5LmNhc2VzKSk7XG4gIH0gXG4gIGVsc2UgaWYoIWlzR2xvYmFsQ2FzZXNNb2RlICYmIGlzQWxsQ2FzZXNNb2RlICYmIGlzQ29uZmlybWVkTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gYS50b2RheUNhc2VzIDwgYi50b2RheUNhc2VzID8gMSA6IC0xKTtcbiAgICBEQVRBLmZvckVhY2goKGNvdW50cnkpID0+IGNyZWF0ZUNhcmRzKGNvdW50cnksIGNvdW50cnkudG9kYXlDYXNlcykpO1xuICB9XG4gIGVsc2UgaWYoaXNHbG9iYWxDYXNlc01vZGUgJiYgIWlzQWxsQ2FzZXNNb2RlICYmIGlzQ29uZmlybWVkTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gTWF0aC5yb3VuZCgoYS5jYXNlc1Blck9uZU1pbGxpb24gLyAxMCkpIDwgTWF0aC5yb3VuZCgoYi5jYXNlc1Blck9uZU1pbGxpb24gLyAxMCkpID8gMSA6IC0xKTtcblxuICAgIERBVEEuZm9yRWFjaCgoY291bnRyeSkgPT4ge1xuICAgICAgbGV0IHRvdGFsQ29uZmlybWVkUGVyMTAwID0gTWF0aC5yb3VuZCgoY291bnRyeS5jYXNlc1Blck9uZU1pbGxpb24gLyAxMCkpO1xuXG4gICAgICBjcmVhdGVDYXJkcyhjb3VudHJ5LCB0b3RhbENvbmZpcm1lZFBlcjEwMClcbiAgICB9KTtcbiAgfVxuICBlbHNlIGlmKCFpc0dsb2JhbENhc2VzTW9kZSAmJiAhaXNBbGxDYXNlc01vZGUgJiYgaXNDb25maXJtZWRNb2RlKSB7XG4gICAgREFUQS5zb3J0KChhLCBiKSA9PiBNYXRoLnJvdW5kKChhLnRvZGF5Q2FzZXMgLyBhLnBvcHVsYXRpb24pICogMTAwMDAwKSA8IE1hdGgucm91bmQoKGIudG9kYXlDYXNlcyAvIGIucG9wdWxhdGlvbikgKiAxMDAwMDApID8gMSA6IC0xKTtcbiAgICBcbiAgICBEQVRBLmZvckVhY2goKGNvdW50cnkpID0+IHtcbiAgICAgIGxldCBuZXdDb25maXJtZWRQZXIxMDAgPSBNYXRoLnJvdW5kKChjb3VudHJ5LnRvZGF5Q2FzZXMgLyBjb3VudHJ5LnBvcHVsYXRpb24pICogMTAwMDAwKTtcbiAgICAgIGNyZWF0ZUNhcmRzKGNvdW50cnksIG5ld0NvbmZpcm1lZFBlcjEwMCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIGVsc2UgaWYoaXNHbG9iYWxDYXNlc01vZGUgJiYgaXNBbGxDYXNlc01vZGUgJiYgaXNEZWF0aENhc2VzTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gYS5kZWF0aHMgPCBiLmRlYXRocyA/IDEgOiAtMSk7XG4gICAgREFUQS5mb3JFYWNoKChjb3VudHJ5KSA9PiBjcmVhdGVDYXJkcyhjb3VudHJ5LCBjb3VudHJ5LmRlYXRocykpO1xuICB9IFxuICBlbHNlIGlmKCFpc0dsb2JhbENhc2VzTW9kZSAmJiBpc0FsbENhc2VzTW9kZSAmJiBpc0RlYXRoQ2FzZXNNb2RlKSB7XG4gICAgREFUQS5zb3J0KChhLCBiKSA9PiBhLnRvZGF5RGVhdGhzIDwgYi50b2RheURlYXRocyA/IDEgOiAtMSk7XG4gICAgREFUQS5mb3JFYWNoKChjb3VudHJ5KSA9PiBjcmVhdGVDYXJkcyhjb3VudHJ5LCBjb3VudHJ5LnRvZGF5RGVhdGhzKSk7XG4gIH1cbiAgZWxzZSBpZihpc0dsb2JhbENhc2VzTW9kZSAmJiAhaXNBbGxDYXNlc01vZGUgJiYgaXNEZWF0aENhc2VzTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gTWF0aC5yb3VuZCgoYS5kZWF0aHMgLyBhLnBvcHVsYXRpb24pICogMTAwMDAwKSA8IE1hdGgucm91bmQoKGIuZGVhdGhzIC8gYi5wb3B1bGF0aW9uKSAqIDEwMDAwMCkgPyAxIDogLTEpO1xuICBcbiAgICBEQVRBLmZvckVhY2goKGNvdW50cnkpID0+IHtcbiAgICAgIGxldCB0b3RhbERlYXRoc1BlcjEwMCA9IE1hdGgucm91bmQoKGNvdW50cnkuZGVhdGhzIC8gY291bnRyeS5wb3B1bGF0aW9uKSAqIDEwMDAwMCk7XG4gICAgICBjcmVhdGVDYXJkcyhjb3VudHJ5LCB0b3RhbERlYXRoc1BlcjEwMCk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSBpZighaXNHbG9iYWxDYXNlc01vZGUgJiYgIWlzQWxsQ2FzZXNNb2RlICYmIGlzRGVhdGhDYXNlc01vZGUpIHtcbiAgICBEQVRBLnNvcnQoKGEsIGIpID0+IE1hdGgucm91bmQoKGEudG9kYXlEZWF0aHMgLyBhLnBvcHVsYXRpb24pICogMTAwMDAwKSA8IE1hdGgucm91bmQoKGIudG9kYXlEZWF0aHMgLyBiLnBvcHVsYXRpb24pICogMTAwMDAwKSA/IDEgOiAtMSk7XG4gIFxuICAgIERBVEEuZm9yRWFjaCgoY291bnRyeSkgPT4ge1xuICAgICAgbGV0IG5ld0RlYXRoc1BlcjEwMCA9IE1hdGgucm91bmQoKGNvdW50cnkudG9kYXlEZWF0aHMgLyBjb3VudHJ5LnBvcHVsYXRpb24pICogMTAwMDAwKTtcbiAgICAgIGNyZWF0ZUNhcmRzKGNvdW50cnksIG5ld0RlYXRoc1BlcjEwMCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIGVsc2UgaWYoaXNHbG9iYWxDYXNlc01vZGUgJiYgaXNBbGxDYXNlc01vZGUgJiYgaXNSZWNvdmVyZWRNb2RlKSB7XG4gICAgREFUQS5zb3J0KChhLCBiKSA9PiBhLnJlY292ZXJlZCA8IGIucmVjb3ZlcmVkID8gMSA6IC0xKTtcbiAgICBEQVRBLmZvckVhY2goKGNvdW50cnkpID0+IGNyZWF0ZUNhcmRzKGNvdW50cnksIGNvdW50cnkucmVjb3ZlcmVkKSk7XG4gIH0gXG4gIGVsc2UgaWYoIWlzR2xvYmFsQ2FzZXNNb2RlICYmIGlzQWxsQ2FzZXNNb2RlICYmIGlzUmVjb3ZlcmVkTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gYS50b2RheVJlY292ZXJlZCA8IGIudG9kYXlSZWNvdmVyZWQgPyAxIDogLTEpO1xuICAgIERBVEEuZm9yRWFjaCgoY291bnRyeSkgPT4gY3JlYXRlQ2FyZHMoY291bnRyeSwgY291bnRyeS50b2RheVJlY292ZXJlZCkpO1xuICB9XG4gIGVsc2UgaWYoaXNHbG9iYWxDYXNlc01vZGUgJiYgIWlzQWxsQ2FzZXNNb2RlICYmIGlzUmVjb3ZlcmVkTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gTWF0aC5yb3VuZCgoYS5yZWNvdmVyZWQgLyBhLnBvcHVsYXRpb24pICogMTAwMDAwKSA8IE1hdGgucm91bmQoKGIucmVjb3ZlcmVkIC8gYi5wb3B1bGF0aW9uKSAqIDEwMDAwMCkgPyAxIDogLTEpO1xuICBcbiAgICBEQVRBLmZvckVhY2goKGNvdW50cnkpID0+IHtcbiAgICAgIGxldCB0b3RhbFJlY292ZXJlZFBlcjEwMCA9IE1hdGgucm91bmQoKGNvdW50cnkucmVjb3ZlcmVkIC8gY291bnRyeS5wb3B1bGF0aW9uKSAqIDEwMDAwMCk7XG4gICAgICBjcmVhdGVDYXJkcyhjb3VudHJ5LCB0b3RhbFJlY292ZXJlZFBlcjEwMCk7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSBpZighaXNHbG9iYWxDYXNlc01vZGUgJiYgIWlzQWxsQ2FzZXNNb2RlICYmIGlzUmVjb3ZlcmVkTW9kZSkge1xuICAgIERBVEEuc29ydCgoYSwgYikgPT4gTWF0aC5yb3VuZCgoYS50b2RheVJlY292ZXJlZCAvIGEucG9wdWxhdGlvbikgKiAxMDAwMDApIDwgTWF0aC5yb3VuZCgoYi50b2RheVJlY292ZXJlZCAvIGIucG9wdWxhdGlvbikgKiAxMDAwMDApID8gMSA6IC0xKTtcbiAgXG4gICAgREFUQS5mb3JFYWNoKChjb3VudHJ5KSA9PiB7XG4gICAgICBsZXQgbmV3UmVjb3ZlcmVkUGVyMTAwID0gTWF0aC5yb3VuZCgoY291bnRyeS50b2RheVJlY292ZXJlZCAvIGNvdW50cnkucG9wdWxhdGlvbikgKiAxMDAwMDApO1xuICAgICAgY3JlYXRlQ2FyZHMoY291bnRyeSwgbmV3UmVjb3ZlcmVkUGVyMTAwKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy9jcmVhdGUgZWxlbWV0c1xuY29uc3QgY3JlYXRlQ2FyZHMgPSAoY291bnRyeSwgbnVtYmVycykgPT4ge1xuICBjb25zdCBjb3VudHJ5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGNvdW50cnlJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGNvdW50cnlGbGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGNvdW50cnlOYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnN0IGNvdW50cnlDYXNlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAgXG4gIFxuICBjb3VudHJ5Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjb3VudHJ5X19jb250YWluZXInO1xuICBjb3VudHJ5SW5mby5jbGFzc05hbWUgPSAnY291bnRyeV9faW5mbyc7XG4gIGNvdW50cnlGbGFnLmNsYXNzTmFtZSA9ICdjb3VudHJ5X19mbGFnJztcbiAgY291bnRyeU5hbWUuY2xhc3NOYW1lID0gJ2NvdW50cnlfX25hbWUnO1xuICBjb3VudHJ5Q2FzZXMuY2xhc3NOYW1lID0gJ2NvdW50cnlfX2Nhc2VzJztcblxuICBjb3VudHJ5TmFtZS5pbm5lclRleHQgPSBjb3VudHJ5LmNvdW50cnk7XG4gIGNvdW50cnlDYXNlcy5pbm5lclRleHQgPSBudW1iZXJzO1xuICBjb3VudHJ5RmxhZy5pbm5lckhUTUwgPSBgPGltZyBzcmM9XCIke2NvdW50cnkuY291bnRyeUluZm8uZmxhZ31cIiBjbGFzcz1cImZsYWdfX2ltZ1wiPmA7XG5cbiAgY291bnRyaWVzLmFwcGVuZChjb3VudHJ5Q29udGFpbmVyKTtcbiAgY291bnRyeUNvbnRhaW5lci5hcHBlbmQoY291bnRyeUluZm8sIGNvdW50cnlDYXNlcyk7XG4gIGNvdW50cnlJbmZvLmFwcGVuZChjb3VudHJ5RmxhZywgY291bnRyeU5hbWUpO1xufTtcblxuY29uc3Qgb25DaGFuZ2UgPSAoaW5wdXQpID0+IHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5pbnB1dFwiKS52YWx1ZSA9IGlucHV0O1xuICBzZWFyY2hUZXJtID0gaW5wdXQ7XG4gIGNvdW50cmllcy5pbm5lckhUTUwgPSAnJztcblxuICBnZXRJbmZvKCk7XG59O1xuXG4vL2NoYW5nZSBTd2l0Y2hlcnNcbmNvbnN0IGNoYW5nZVN3aXRjaGVyTW9kZUJ0biA9IChmaXJzdE1vZGUsIHNlY29uZE1vZGUpID0+IHtcbiAgZmlyc3RNb2RlLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGUnKTtcbiAgc2Vjb25kTW9kZS5jbGFzc0xpc3QudG9nZ2xlKCdoaWRlJyk7XG59XG5cbmNvbnN0IGNoYW5nZVN3aXRjaGVyc0RheXNNb2RlID0gKCkgPT4ge1xuICBpZihpc0dsb2JhbENhc2VzTW9kZSkge1xuICAgIGlzR2xvYmFsQ2FzZXNNb2RlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaXNHbG9iYWxDYXNlc01vZGUgPSB0cnVlO1xuICB9XG4gIGNoYW5nZVN3aXRjaGVyTW9kZUJ0bihnbG9iYWxDYXNlcywgZGFpbHlDYXNlcyk7XG59O1xuXG5jb25zdCBjaGFuZ2VTd2l0Y2hlcnNDYXNlc01vZGUgPSAoKSA9PiB7XG4gIGlmKGlzQWxsQ2FzZXNNb2RlKSB7XG4gICAgaXNBbGxDYXNlc01vZGUgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0FsbENhc2VzTW9kZSA9IHRydWU7XG4gIH1cbiAgY2hhbmdlU3dpdGNoZXJNb2RlQnRuKGFsbENhc2VzLCB0aG91c2FuZHNDYXNlcyk7XG59O1xuXG4vLyBhZGQgZnVsbCBTY3JlZW5cbmZ1bGxzY3JlZW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmKCFkb2N1bWVudC5mdWxsc2NyZWVuKSB7XG4gICAgbGlzdC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIHZpcnR1YWxLZXlib2FyZC5jbGFzc0xpc3QuYWRkKCdmdWxsc2NyZWVuX2tleWInKTtcbiAgICBmdWxsc2NyZWVuQnRuLnN0eWxlLnRvcCA9ICcwLjVyZW0nO1xuICAgIGZ1bGxzY3JlZW5CdG4uc3R5bGUucmlnaHQgPSAnMC41cmVtJztcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xuICAgIHZpcnR1YWxLZXlib2FyZC5jbGFzc0xpc3QucmVtb3ZlKCdmdWxsc2NyZWVuX2tleWInKTtcbiAgICBmdWxsc2NyZWVuQnRuLnN0eWxlLnRvcCA9ICctMC40cmVtJztcbiAgICBmdWxsc2NyZWVuQnRuLnN0eWxlLnJpZ2h0ID0gJy0wLjRyZW0nO1xuICB9O1xufSk7XG5cbmRheXNNb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBjb3VudHJpZXMuaW5uZXJIVE1MID0gJyc7XG4gIGNoYW5nZVN3aXRjaGVyc0RheXNNb2RlKCk7XG4gIGdldEluZm8oKTtcbn0pO1xuXG5jb3VudHNNb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICBjb3VudHJpZXMuaW5uZXJIVE1MID0gJyc7XG4gIGNoYW5nZVN3aXRjaGVyc0Nhc2VzTW9kZSgpO1xuICBnZXRJbmZvKCk7XG59KTtcblxuLy9jaGFuZ2UgaW5kaWNhdG9yc1xuYXJyb3dSaWdodC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgaWYoY291bnRDbGlja0Fycm93ID09PSAwKSB7XG4gICAgY29uZmlybWVkLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICBkZWF0aHMuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuICAgIFxuICAgIGFycm93TGVmdC5jbGFzc0xpc3QucmVtb3ZlKCd1bmFjdGl2ZScpO1xuXG4gICAgY291bnRDbGlja0Fycm93ID0gMTtcbiAgICBpc0NvbmZpcm1lZE1vZGUgPSBmYWxzZTtcbiAgICBpc0RlYXRoQ2FzZXNNb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIGVsc2UgaWYoY291bnRDbGlja0Fycm93ID09PSAxKSB7XG4gICAgZGVhdGhzLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcbiAgICByZWNvdmVyZWQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpO1xuXG4gICAgYXJyb3dSaWdodC5jbGFzc0xpc3QuYWRkKCd1bmFjdGl2ZScpO1xuXG4gICAgY291bnRDbGlja0Fycm93ID0gMjtcbiAgICBpc0RlYXRoQ2FzZXNNb2RlID0gZmFsc2U7XG4gICAgaXNSZWNvdmVyZWRNb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIGNvdW50cmllcy5pbm5lckhUTUwgPSAnJztcbiAgZ2V0SW5mbygpO1xufSk7XG5cbmFycm93TGVmdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgaWYoY291bnRDbGlja0Fycm93ID09PSAxKSB7XG4gICAgY29uZmlybWVkLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcbiAgICBkZWF0aHMuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuXG4gICAgYXJyb3dMZWZ0LmNsYXNzTGlzdC5hZGQoJ3VuYWN0aXZlJylcblxuICAgIGNvdW50Q2xpY2tBcnJvdyA9IDA7XG4gICAgaXNEZWF0aENhc2VzTW9kZSA9IGZhbHNlO1xuICAgIGlzQ29uZmlybWVkTW9kZSA9IHRydWU7XG4gIH1cbiAgXG4gIGVsc2UgaWYoY291bnRDbGlja0Fycm93ID09PSAyKSB7XG4gICAgZGVhdGhzLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKTtcbiAgICByZWNvdmVyZWQuY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xuXG4gICAgYXJyb3dSaWdodC5jbGFzc0xpc3QucmVtb3ZlKCd1bmFjdGl2ZScpO1xuXG4gICAgY291bnRDbGlja0Fycm93ID0gMTtcbiAgICBpc0RlYXRoQ2FzZXNNb2RlID0gdHJ1ZTtcbiAgICBpc1JlY292ZXJlZE1vZGUgPSBmYWxzZTtcbiAgfVxuXG4gIGNvdW50cmllcy5pbm5lckhUTUwgPSAnJztcbiAgZ2V0SW5mbygpO1xufSk7XG5cbmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGV2ZW50KSA9PiB7XG4gIHNlYXJjaFRlcm0gPSBldmVudC50YXJnZXQudmFsdWU7XG5cbiAgY291bnRyaWVzLmlubmVySFRNTCA9ICcnO1xuXG4gIGdldEluZm8oKTtcbn0pO1xuXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmlucHV0XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gIGtleWJvYXJkLnNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG59KTtcblxua2V5Ym9hcmRCdG4uYWRkRXZlbnRMaXN0ZW5lciAoJ2NsaWNrJywgKCkgPT4ge1xuICBrZXlib2FyZENvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKCdoaWRlJyk7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gIGdldEluZm8oKTtcbn0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbmNvbnN0IGNoYXJ0R2xvYmFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0X2dsb2JhbF9pZCcpO1xuY29uc3QgZ2xvYmFsQ2FzZXNCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2hhcnRfX2NvbnRyb2xfZ2xvYmFsJyk7XG5cbmNvbnN0IHdvcmxkQ2FzZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2hhcnRfX2dsb2JhbCcpO1xuXG5jb25zdCBjaGFydERhaWx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0X2RhaWx5X2lkJyk7XG5jb25zdCBkYWlseUNhc2VzQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNoYXJ0X19jb250cm9sX2RhaWx5Jyk7XG5cbmNvbnN0IGNoYXJ0SHVuZHJlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydF9odW5kcmVkX2lkJyk7XG5jb25zdCBodW5kcmVkQ2FzZXNCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2hhcnRfX2NvbnRyb2xfaHVuZHJlZCcpO1xuXG5jb25zdCBjaGFydEJ0bkNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaGFydF9fY29udHJvbCcpO1xuY29uc3QgZnVsbHNjcmVlbkNoYXJ0QnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAoJy5mdWxsc2NyZWVuX19jaGFydCcpO1xuY29uc3QgY2hhcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICgnLmNoYXJ0Jyk7XG5cbmNvbnN0IGdsb2JhbENvbmZpcm1lZCA9IFtdO1xuY29uc3QgZ2xvYmFsRGVhdGhzID0gW107XG5jb25zdCBnbG9iYWxSZWNvdmVyZWQgPSBbXTtcbmNvbnN0IGRhdGVTdGFnZSA9IFtdO1xuY29uc3QgcmlnaHREYXRlID0gW107XG5cbmNvbnN0IG5ld0NvbmZpcm1lZCA9IFtdO1xubGV0IGxhc3REYXRlID0gJyc7XG5jb25zdCBuZXdSZWNvdmVyZWQgPSBbXTtcbmNvbnN0IG5ld0RlYXRocyA9IFtdO1xuXG5sZXQgZ2xvYmFsQ2hhcnRDcmVhdGVkO1xubGV0IGRhaWx5Q2hhcnRDcmVhdGVkO1xubGV0IGh1bmRyZWRDaGFydENyZWF0ZWQ7XG5cbmxldCBpc1Nob3dDaGFydCA9IHRydWU7XG5sZXQgaXNIdW5kcmVkQ2hhcnQgPSB0cnVlO1xuXG5jb25zdCB3b3JsZFBvcHVsYXRpb25QZXIxMDAgPSA3ODI3MDtcbmNvbnN0IGdsb2JhbEh1bmRyZWRDb25maXJtZWQgPSBbXTtcbmNvbnN0IGdsb2JhbEh1bmRyZWREZWF0aHMgPSBbXTtcbmNvbnN0IGdsb2JhbEh1bmRyZWRSZWNvdmVyZWQgPSBbXTtcblxuY29uc3QgdG9kYXlIdW5kcmVkQ29uZmlybWVkID0gW107XG5jb25zdCB0b2RheUh1bmRyZWREZWF0aHMgPSBbXTtcbmNvbnN0IHRvZGF5SHVuZHJlZFJlY292ZXJlZCA9IFtdO1xuXG5jb25zdCBtb250aHNOYW1lcyA9IFtcbiAgJ0phbicsXG4gICdGZWInLFxuICAnTWFyJyxcbiAgJ0FwcicsXG4gICdNYXknLFxuICAnSnVuJyxcbiAgJ0p1bCcsXG4gICdBdWcnLFxuICAnU2VwJyxcbiAgJ09jdCcsXG4gICdOb3YnLFxuICAnRGVjJyxcbl07XG5cbmNvbnN0IGZvcm1hdHRlZERhdGUgPSAocGFyc2VEYXRlKSA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwYXJzZURhdGUpO1xuICByZXR1cm4gYCR7ZGF0ZS5nZXREYXRlKCl9ICR7bW9udGhzTmFtZXNbZGF0ZS5nZXRNb250aCgpXX1gO1xufTtcblxuY29uc3Qgc29ydERhdGEgPSAoKSA9PiB7XG4gIGdsb2JhbENvbmZpcm1lZC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGdsb2JhbERlYXRocy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGdsb2JhbFJlY292ZXJlZC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cbiAgZ2xvYmFsSHVuZHJlZENvbmZpcm1lZC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGdsb2JhbEh1bmRyZWREZWF0aHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBnbG9iYWxIdW5kcmVkUmVjb3ZlcmVkLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcblxuICB0b2RheUh1bmRyZWRDb25maXJtZWQuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB0b2RheUh1bmRyZWREZWF0aHMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICB0b2RheUh1bmRyZWRSZWNvdmVyZWQuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIGRhdGVTdGFnZS5zb3J0KCk7XG5cbiAgZGF0ZVN0YWdlLmZvckVhY2goKGVsKSA9PiB7XG4gICAgcmlnaHREYXRlLnB1c2goZm9ybWF0dGVkRGF0ZShlbCkpO1xuICB9KTtcbn07XG5cbmNvbnN0IGdsb2JhbENoYXJ0QWN0aW9uID0gKCkgPT4ge1xuICBpZiAoIWlzU2hvd0NoYXJ0IHx8ICFpc0h1bmRyZWRDaGFydCkge1xuICAgIGNoYXJ0RGFpbHkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgd29ybGRDYXNlcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBjaGFydEh1bmRyZWQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgaXNTaG93Q2hhcnQgPSB0cnVlO1xuICAgIGlzSHVuZHJlZENoYXJ0ID0gdHJ1ZTtcbiAgfVxufTtcblxuY29uc3QgZGFpbHlDaGFydEFjdGlvbiA9ICgpID0+IHtcbiAgaWYgKGlzU2hvd0NoYXJ0IHx8ICFpc0h1bmRyZWRDaGFydCkge1xuICAgIHdvcmxkQ2FzZXMuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgY2hhcnREYWlseS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBjaGFydEh1bmRyZWQuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgaXNTaG93Q2hhcnQgPSBmYWxzZTtcbiAgICBpc0h1bmRyZWRDaGFydCA9IHRydWU7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZURhaWx5Q2hhcnQgPSAoKSA9PiB7XG4gIGRhaWx5Q2hhcnRDcmVhdGVkID0gbmV3IENoYXJ0KGNoYXJ0RGFpbHksIHtcbiAgICB0eXBlOiAnZG91Z2hudXQnLFxuICAgIGRhdGE6IHtcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ1RvZGF5YHMgQ2hhcnQnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogWycjM2U5NWNkJywgJyM4ZTVlYTInLCAnIzNjYmE5ZiddLFxuICAgICAgICAgIGRhdGE6IFtuZXdDb25maXJtZWQsIG5ld1JlY292ZXJlZCwgbmV3RGVhdGhzXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBsYWJlbHM6IFtcbiAgICAgICAgJ05ldyBDb25maXJtZWQnLFxuICAgICAgICAnTmV3IFJlY292ZXJlZCcsXG4gICAgICAgICdOZXcgRGVhdGhzJyxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiBgVG9kYXlcXGBzIENhc2VzOiAke2xhc3REYXRlfWAsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBkYWlseUNoYXJ0Q3JlYXRlZDtcbn07XG5cbmNvbnN0IGh1bmRyZWRDaGFydEFjdGlvbiA9ICgpID0+IHtcbiAgaWYgKGlzSHVuZHJlZENoYXJ0KSB7XG4gICAgd29ybGRDYXNlcy5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICBjaGFydERhaWx5LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgIGNoYXJ0SHVuZHJlZC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICBpc0h1bmRyZWRDaGFydCA9IGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVIdW5kcmVkQ2hhcnQgPSAoKSA9PiB7XG4gIGh1bmRyZWRDaGFydENyZWF0ZWQgPSBuZXcgQ2hhcnQoY2hhcnRIdW5kcmVkLCB7XG4gICAgdHlwZTogJ2xpbmUnLFxuICAgIGRhdGE6IHtcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ0dsb2JhbCBQZXIgMTAwIENvbmZpcm1lZCcsXG4gICAgICAgICAgZGF0YTogZ2xvYmFsSHVuZHJlZENvbmZpcm1lZCxcbiAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyMzZTk1Y2QnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzZTk1Y2QnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdHbG9iYWwgUGVyIDEwMCBSZWNvdmVyZWQnLFxuICAgICAgICAgIGRhdGE6IGdsb2JhbEh1bmRyZWRSZWNvdmVyZWQsXG4gICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjOGU1ZWEyJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjOGU1ZWEyJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiAnR2xvYmFsIFBlciAxMDAgRGVhdGhzJyxcbiAgICAgICAgICBkYXRhOiBnbG9iYWxIdW5kcmVkRGVhdGhzLFxuICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAncmVkJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZWQnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdUb2RheSBQZXIgMTAwIENvbmZpcm1lZCcsXG4gICAgICAgICAgZGF0YTogdG9kYXlIdW5kcmVkQ29uZmlybWVkLFxuICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiAnVG9kYXkgUGVyIDEwMCBSZWNvdmVyZWQnLFxuICAgICAgICAgIGRhdGE6IHRvZGF5SHVuZHJlZFJlY292ZXJlZCxcbiAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsdWUnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdUb2RheSBQZXIgMTAwIERlYXRocycsXG4gICAgICAgICAgZGF0YTogdG9kYXlIdW5kcmVkRGVhdGhzLFxuICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzNjYmE5ZicsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzNjYmE5ZicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgbGFiZWxzOiByaWdodERhdGUsXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBib3hXaWR0aDogMjAsXG4gICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgIGZvbnRDb2xvcjogJ2RhcmtzbGF0ZWdyYXknLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICB9LFxuICB9KTtcblxuICByZXR1cm4gaHVuZHJlZENoYXJ0Q3JlYXRlZDtcbn07XG5cbmNvbnN0IGNvdmlkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9jb3JvbmEtYXBpLmNvbS90aW1lbGluZScpO1xuICBjb25zdCBjb3ZpZEFwaURhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgY29uc3QgeyBkYXRhIH0gPSBjb3ZpZEFwaURhdGE7XG5cbiAgZGF0YS5mb3JFYWNoKChlbCkgPT4ge1xuICAgIGRhdGVTdGFnZS5wdXNoKGVsLmRhdGUpO1xuICAgIGdsb2JhbENvbmZpcm1lZC5wdXNoKGVsLmNvbmZpcm1lZCk7XG4gICAgZ2xvYmFsRGVhdGhzLnB1c2goZWwuZGVhdGhzKTtcbiAgICBnbG9iYWxSZWNvdmVyZWQucHVzaChlbC5yZWNvdmVyZWQpO1xuXG4gICAgZ2xvYmFsSHVuZHJlZENvbmZpcm1lZC5wdXNoKE1hdGgucm91bmQoZWwuY29uZmlybWVkIC8gd29ybGRQb3B1bGF0aW9uUGVyMTAwKSk7XG4gICAgZ2xvYmFsSHVuZHJlZERlYXRocy5wdXNoKE1hdGgucm91bmQoZWwuZGVhdGhzIC8gd29ybGRQb3B1bGF0aW9uUGVyMTAwKSk7XG4gICAgZ2xvYmFsSHVuZHJlZFJlY292ZXJlZC5wdXNoKE1hdGgucm91bmQoZWwucmVjb3ZlcmVkIC8gd29ybGRQb3B1bGF0aW9uUGVyMTAwKSk7XG5cbiAgICB0b2RheUh1bmRyZWRDb25maXJtZWQucHVzaChNYXRoLnJvdW5kKGVsLm5ld19jb25maXJtZWQgLyB3b3JsZFBvcHVsYXRpb25QZXIxMDApKTtcbiAgICB0b2RheUh1bmRyZWREZWF0aHMucHVzaChNYXRoLnJvdW5kKGVsLm5ld19kZWF0aHMgLyB3b3JsZFBvcHVsYXRpb25QZXIxMDApKTtcbiAgICB0b2RheUh1bmRyZWRSZWNvdmVyZWQucHVzaChNYXRoLnJvdW5kKGVsLm5ld19yZWNvdmVyZWQgLyB3b3JsZFBvcHVsYXRpb25QZXIxMDApKTtcbiAgfSk7XG5cbiAgbmV3Q29uZmlybWVkLnB1c2goZGF0YVswXS5uZXdfY29uZmlybWVkKTtcbiAgbmV3UmVjb3ZlcmVkLnB1c2goZGF0YVswXS5uZXdfcmVjb3ZlcmVkKTtcbiAgbmV3RGVhdGhzLnB1c2goZGF0YVswXS5uZXdfZGVhdGhzKTtcbiAgbGFzdERhdGUgKz0gZGF0YVswXS5kYXRlO1xuXG4gIHNvcnREYXRhKCk7XG4gIGNyZWF0ZURhaWx5Q2hhcnQoKTtcbiAgY3JlYXRlSHVuZHJlZENoYXJ0KCk7XG59O1xuXG5jb25zdCBjaGFydEJ1dHRvbkFjdGl2ZSA9IChldmVudCkgPT4ge1xuICBjb25zdCB0YXJnZXRCdG4gPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IGFjdGl2ZUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vcGVuJyk7XG5cbiAgaWYgKHRhcmdldEJ0bi5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09ICdjaGFydF9fY29udHJvbCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYWN0aXZlQnRuICE9PSBudWxsKSB7XG4gICAgYWN0aXZlQnRuLmNsYXNzTGlzdC5yZW1vdmUoJ29wZW4nKTtcbiAgfVxuICB0YXJnZXRCdG4uY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xufTtcblxuY29uc3QgY3JlYXRlR2xvYmFsQ2hhcnQgPSBhc3luYyAoKSA9PiB7XG4gIHdvcmxkQ2FzZXMuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgYXdhaXQgY292aWREYXRhKCk7XG5cbiAgZ2xvYmFsQ2hhcnRDcmVhdGVkID0gbmV3IENoYXJ0KGNoYXJ0R2xvYmFsLCB7XG4gICAgdHlwZTogJ2xpbmUnLFxuICAgIGRhdGE6IHtcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ0dsb2JhbCBDb25maXJtZWQnLFxuICAgICAgICAgIGRhdGE6IGdsb2JhbENvbmZpcm1lZCxcbiAgICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyMzZTk1Y2QnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzZTk1Y2QnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbGFiZWw6ICdHbG9iYWwgUmVjb3ZlcmVkJyxcbiAgICAgICAgICBkYXRhOiBnbG9iYWxSZWNvdmVyZWQsXG4gICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjOGU1ZWEyJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjOGU1ZWEyJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiAnR2xvYmFsIERlYXRocycsXG4gICAgICAgICAgZGF0YTogZ2xvYmFsRGVhdGhzLFxuICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzNjYmE5ZicsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzNjYmE5ZicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgbGFiZWxzOiByaWdodERhdGUsXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246ICd0b3AnLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBib3hXaWR0aDogNTAsXG4gICAgICAgICAgZm9udENvbG9yOiAnYmxhY2snLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB5QXhlczogW3tcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfV0sXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBnbG9iYWxDaGFydENyZWF0ZWQ7XG59O1xuXG5mdWxsc2NyZWVuQ2hhcnRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gIGlmKCFkb2N1bWVudC5mdWxsc2NyZWVuKSB7XG4gICAgY2hhcnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICBmdWxsc2NyZWVuQ2hhcnRCdG4uc3R5bGUudG9wID0gJzAuNXJlbSc7XG4gICAgZnVsbHNjcmVlbkNoYXJ0QnRuLnN0eWxlLnJpZ2h0ID0gJzAuNXJlbSc7XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICBmdWxsc2NyZWVuQ2hhcnRCdG4uc3R5bGUudG9wID0gJy0wLjRyZW0nO1xuICAgIGZ1bGxzY3JlZW5DaGFydEJ0bi5zdHlsZS5yaWdodCA9ICctMC40cmVtJztcbiAgfTtcbn0pO1xuXG5nbG9iYWxDYXNlc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGdsb2JhbENoYXJ0QWN0aW9uKCkpO1xuZGFpbHlDYXNlc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGRhaWx5Q2hhcnRBY3Rpb24oKSk7XG5odW5kcmVkQ2FzZXNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBodW5kcmVkQ2hhcnRBY3Rpb24oKSk7XG5jaGFydEJ0bkNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4gY2hhcnRCdXR0b25BY3RpdmUoZXZlbnQpKTtcblxuY3JlYXRlR2xvYmFsQ2hhcnQoKTtcbiIsImltcG9ydCAnLi4vc3R5bGVzL3Njc3MvbWFpbi5zY3NzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL21hcCc7XG5pbXBvcnQgJy4vY29tcG9uZW50cy90YWJsZSc7XG5pbXBvcnQgJy4vY29tcG9uZW50cy9saXN0JztcbmltcG9ydCAnLi9jb21wb25lbnRzL2NoYXJ0JztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")}]);